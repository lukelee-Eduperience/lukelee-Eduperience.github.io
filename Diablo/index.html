<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ARPG Demo with Spritesheet１</title>
<style>
  :root{
    --bg:#0b0f12; --panel:#0f1720; --muted:#9fb1b8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018,#08121a);color:#e6eef2;font-family:Inter, "Segoe UI", Roboto, Arial;display:flex;align-items:center;justify-content:center;}
  .wrap{width:98vw;max-width:1100px;padding:12px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  canvas{background:#081217;border-radius:8px;display:block;width:100%;max-width:960px}
  .controls{margin-top:8px}
  .hud{color:#cfe6ea}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h2>ARPG Demo — Spritesheet 範例</h2>
      <div style="color:var(--muted)">移動：WASD / 方向鍵 / 右鍵點選；攻擊：左鍵；空格或 F 發射遠程</div>
    </header>

    <canvas id="game" width="960" height="600"></canvas>
    <div style="margin-top:8px;color:#9fb7c6" id="status">載入中資源...</div>
  </div>

<script>
/*
  本範例示範如何使用 spritesheet（單圖）來繪製角色動畫。
  精靈圖使用 data URL 內嵌 PNG（小尺寸示範），你可用外部圖檔替換。
  主要流程：
   - 建立 Image 並設定 src
   - 定義動畫剪輯（每個剪輯的起始格、格子寬高、帧數、耗時）
   - 在 draw 時使用 context.drawImage(sprite, sx, sy, sw, sh, dx, dy, dw, dh)
*/

// 基本 canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const statusEl = document.getElementById('status');

// 資源（內嵌示範 spritesheet）
// 為了保持單檔，我產生一個簡單的 128x128 PNG sprite sheet (4x4 tiles) 的 dataURL。
// 這是用小方塊畫出的示範圖（你可用真實貼圖替換）
const demoSpriteDataURL = (function(){
  // 生成一個小 PNG dataURL programmatically using canvas
  const c = document.createElement('canvas');
  c.width = 128; c.height = 128;
  const g = c.getContext('2d');
  // 背景透明
  g.clearRect(0,0,128,128);
  const colors = ['#c8e3ff','#ffd0b0','#ffd57f','#ffc0ff'];
  // 4x4 tiles, 每格 32x32
  for (let row=0; row<4; row++){
    for (let col=0; col<4; col++){
      const x = col*32, y = row*32;
      g.fillStyle = '#0b1316';
      g.fillRect(x,y,32,32);
      // 畫一圓代表角色或敵人外觀（不同顏色）
      g.beginPath();
      g.fillStyle = colors[(row+col)%colors.length];
      g.arc(x+16, y+16, 10 - Math.floor((row+col)/4), 0, Math.PI*2);
      g.fill();
      // simple face dot
      g.fillStyle = 'rgba(0,0,0,0.25)';
      g.fillRect(x+13, y+14, 2, 2);
      g.fillRect(x+17, y+14, 2, 2);
    }
  }
  return c.toDataURL('image/png');
})();

// load image
const spriteImg = new Image();
let resourcesLoaded = false;
spriteImg.onload = ()=>{ resourcesLoaded = true; statusEl.textContent = '資源載入完成'; initGame(); };
spriteImg.onerror = ()=>{ statusEl.textContent = '載入精靈表失敗'; };
spriteImg.src = demoSpriteDataURL; // 若要使用外部圖檔，改成 URL 字串

// Spritesheet 布局說明（本示範）
// 假設 spritesheet 為 grid 格式：cols x rows，每格 tileW x tileH 像素。
// 你可以用下列 AnimationClip 定義不同動作對應的起始格、長度與播放速度。

const SPRITE = {
  img: spriteImg,
  tileW: 32,
  tileH: 32,
  cols: 4,
  rows: 4
};

// 動畫剪輯
// 每個 clip： { name, row, startCol, frames, speed } speed = 秒/帧
// 本 demo 將利用不同列代表不同動作
const ANIM_CLIPS = {
  player: [
    {name:'idle', row:0, start:0, frames:2, speed:0.4},
    {name:'walk', row:0, start:2, frames:2, speed:0.12},
    {name:'attack', row:1, start:0, frames:2, speed:0.08}
  ],
  enemy: [
    {name:'idle', row:2, start:0, frames:2, speed:0.5},
    {name:'walk', row:2, start:2, frames:2, speed:0.15},
    {name:'die', row:3, start:0, frames:2, speed:0.2}
  ]
};

// Animation helper
class Animator {
  constructor(clips){
    this.clips = clips; // array of clip definitions
    this.current = clips[0]; // default
    this.time = 0;
    this.frameIndex = 0;
  }
  play(name){
    const c = this.clips.find(x=>x.name===name);
    if (!c) return;
    if (this.current === c) return;
    this.current = c; this.time = 0; this.frameIndex = 0;
  }
  update(dt){
    this.time += dt;
    const sp = this.current.speed;
    while (this.time >= sp){
      this.time -= sp;
      this.frameIndex = (this.frameIndex + 1) % this.current.frames;
    }
  }
  // return source rectangle for current frame
  frameRect(){
    const col = this.current.start + this.frameIndex;
    const row = this.current.row;
    return {
      sx: col * SPRITE.tileW,
      sy: row * SPRITE.tileH,
      sw: SPRITE.tileW,
      sh: SPRITE.tileH
    };
  }
}

// ---------- 簡單遊戲邏輯（與先前相似，但使用 animator） ----------
let lastTs = 0;
let player, entities = [], projectiles = [], drops = [];
let running = false;

// Entity with sprite animator
class SpriteEntity {
  constructor(x,y,kind='player'){
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.radius = 18;
    this.kind = kind;
    this.hp = 50; this.maxHp = 50;
    this.speed = 100;
    this.anim = new Animator(ANIM_CLIPS[kind]);
    this.facing = 1; // 1 right, -1 left
    this.attackTimer = 0;
    this.name = kind === 'player' ? 'Hero' : 'Goblin';
  }
  update(dt){
    // update animator
    this.anim.update(dt);
    // cooldowns
    if (this.attackTimer > 0) this.attackTimer = Math.max(0, this.attackTimer - dt);
    // simple movement damp
    this.x += this.vx * dt; this.y += this.vy * dt;
    this.vx *= 0.9; this.vy *= 0.9;
  }
  draw(ctx){
    // draw shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.ellipse(this.x, this.y + this.radius*0.6, this.radius*0.9, this.radius*0.45, 0, 0, Math.PI*2);
    ctx.fill();

    // draw sprite frame using sprite sheet
    const r = this.anim.frameRect();
    if (resourcesLoaded){
      // drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)
      const dw = this.radius*2;
      const dh = this.radius*2;
      const dx = this.x - dw/2;
      const dy = this.y - dh/2;
      // optional flip horizontally by using save/scale
      ctx.save();
      if (this.facing < 0){
        ctx.translate(dx + dw, 0);
        ctx.scale(-1,1);
        ctx.drawImage(SPRITE.img, r.sx, r.sy, r.sw, r.sh, 0, dy, dw, dh);
      } else {
        ctx.drawImage(SPRITE.img, r.sx, r.sy, r.sw, r.sh, dx, dy, dw, dh);
      }
      ctx.restore();
    } else {
      // fallback circle
      ctx.fillStyle = '#c8e3ff';
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius,0,Math.PI*2); ctx.fill();
    }

    // hp bar
    const bw = this.radius*2, bh = 6;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(this.x - bw/2, this.y - this.radius - 14, bw, bh);
    ctx.fillStyle = (this.hp/this.maxHp>0.5) ? '#7bd07a' : '#ff7b7b';
    ctx.fillRect(this.x - bw/2, this.y - this.radius - 14, bw * Math.max(0, this.hp/this.maxHp), bh);
  }
}

// init simple world after resources loaded
function initGame(){
  statusEl.textContent = '按 N 開始新的遊戲；按 S 儲存；按 L 載入';
  // attach input
  setupInput();
  draw();
}

// simple new game
function newGame(){
  player = new SpriteEntity(W/2, H/2, 'player');
  player.maxHp = 120; player.hp = 120; player.speed = 140;
  entities = [];
  projectiles = []; drops = [];
  // spawn few enemies
  for (let i=0;i<6;i++){
    const e = new SpriteEntity(120 + Math.random()*(W-240), 80 + Math.random()*(H-160), 'enemy');
    e.maxHp = 30; e.hp = 30; e.speed = 70;
    entities.push(e);
  }
  running = true;
  lastTs = performance.now();
  requestAnimationFrame(loop);
}

// input
let keys = {};
let mouse = {x:0,y:0, down:false};
function setupInput(){
  canvas.addEventListener('mousemove',(e)=>{ const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) * (canvas.width / r.width); mouse.y = (e.clientY - r.top) * (canvas.height / r.height); });
  canvas.addEventListener('mousedown',(e)=>{ mouse.down = true; if (e.button===0) tryMelee(); });
  canvas.addEventListener('mouseup',(e)=>{ mouse.down = false; });
  window.addEventListener('keydown',(e)=>{ keys[e.key.toLowerCase()] = true; if (e.key.toLowerCase()==='n') newGame(); if (e.key.toLowerCase()==='s') saveGame(); if (e.key.toLowerCase()==='l') loadGame(); if (e.key.toLowerCase()==='f' || e.key===' ') fireAtMouse(); });
  window.addEventListener('keyup',(e)=>{ keys[e.key.toLowerCase()] = false; });
}

// attack
function tryMelee(){
  if (!player) return;
  if (player.attackTimer > 0) return;
  player.attackTimer = 0.4;
  player.anim.play('attack');
  // check enemies within range
  for (let i=entities.length-1;i>=0;i--){
    const en = entities[i];
    const d = Math.hypot(en.x - player.x, en.y - player.y);
    if (d <= 48 + en.radius){
      en.hp -= 18; playBeep(740,0.04,'square',0.06);
      if (en.hp <= 0) {
        entities.splice(i,1);
        // spawn drop
        drops.push({x:en.x, y:en.y, kind:'gold', amount: randInt(5,20)});
      }
      break;
    }
  }
}

// ranged
function fireAtMouse(){
  if (!player) return;
  // spawn projectile toward mouse
  const [nx,ny] = norm(mouse.x - player.x, mouse.y - player.y);
  const speed = 420;
  projectiles.push({x:player.x + nx*20, y:player.y + ny*20, vx:nx*speed, vy:ny*speed, dmg:12, traveled:0, range:700});
  playBeep(880,0.05,'saw',0.06);
}

// util
function norm(x,y){ const m = Math.hypot(x,y)||1; return [x/m,y/m]; }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function playBeep(freq=440,t=0.06,type='sine',vol=0.06){
  try{
    const a = new (window.AudioContext || window.webkitAudioContext)();
    const o=a.createOscillator(); const g=a.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=vol;
    o.connect(g); g.connect(a.destination); o.start(); o.stop(a.currentTime + t);
  }catch(e){}
}

// main loop
function loop(ts){
  if (!running){ draw(); return; }
  const dt = Math.min(0.05, (ts - lastTs)/1000); lastTs = ts;

  // input movement
  if (player){
    let mvx=0,mvy=0;
    if (keys['w']||keys['arrowup']) mvy -= 1;
    if (keys['s']||keys['arrowdown']) mvy += 1;
    if (keys['a']||keys['arrowleft']) mvx -= 1;
    if (keys['d']||keys['arrowright']) mvx += 1;
    if (mvx !==0 || mvy !==0){
      const [nx,ny] = norm(mvx,mvy);
      player.vx = nx * player.speed;
      player.vy = ny * player.speed;
      player.anim.play('walk');
      player.facing = nx < 0 ? -1 : 1;
    } else {
      // move toward mouse if right button held
      if (mouse.down){
        const dx = mouse.x - player.x, dy = mouse.y - player.y;
        const d = Math.hypot(dx,dy);
        if (d > 6){
          const [nx,ny] = norm(dx,dy);
          player.vx = nx * player.speed;
          player.vy = ny * player.speed;
          player.anim.play('walk');
          player.facing = nx < 0 ? -1 : 1;
        } else {
          player.vx = 0; player.vy = 0; player.anim.play('idle');
        }
      } else {
        player.anim.play('idle');
        player.vx *= 0.8; player.vy *= 0.8;
      }
    }
    player.update(dt);
  }

  // update entities (simple chase)
  for (const e of entities){
    const dx = player.x - e.x, dy = player.y - e.y;
    const d = Math.hypot(dx,dy);
    if (d < 220){
      const [nx,ny] = norm(dx,dy);
      e.vx = nx * e.speed;
      e.vy = ny * e.speed;
      e.anim.play('walk');
      e.facing = nx < 0 ? -1 : 1;
      // if close, attack
      if (d < 36 + player.radius){
        // melee effect
        if (e.attackTimer <= 0){
          e.attackTimer = 0.9;
          player.hp -= 8;
          playBeep(260,0.04,'saw',0.06);
          if (player.hp <= 0){
            running = false; statusEl.textContent = '你死亡了。按 N 開始新的遊戲';
          }
        }
      }
    } else {
      e.vx *= 0.9; e.vy *= 0.9;
      e.anim.play('idle');
    }
    e.update(dt);
  }

  // projectiles
  for (let i = projectiles.length -1; i>=0; i--){
    const p = projectiles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.traveled += Math.hypot(p.vx*dt, p.vy*dt);
    // collide with enemies
    for (let j = entities.length -1; j>=0; j--){
      const e = entities[j];
      const d = Math.hypot(p.x - e.x, p.y - e.y);
      if (d <= e.radius + 6){
        e.hp -= p.dmg;
        projectiles.splice(i,1);
        playBeep(640,0.04,'triangle',0.05);
        if (e.hp <= 0){
          entities.splice(j,1);
          drops.push({x:e.x,y:e.y,kind:'gold',amount:randInt(5,20)});
        }
        break;
      }
    }
    if (p && p.traveled >= p.range) projectiles.splice(i,1);
  }

  // pickup drops
  for (let i = drops.length -1; i>=0; i--){
    const d = drops[i];
    const dd = Math.hypot(d.x - player.x, d.y - player.y);
    if (dd < 24){
      if (d.kind==='gold') { /* collect */ }
      drops.splice(i,1);
    }
  }

  draw();
  requestAnimationFrame(loop);
}

// drawing
function draw(){
  ctx.clearRect(0,0,W,H);
  // background tiles (simple)
  ctx.fillStyle = '#081217';
  ctx.fillRect(0,0,W,H);

  // draw entities
  for (const e of entities) e.draw(ctx);
  // projectiles
  for (const p of projectiles){
    ctx.beginPath(); ctx.fillStyle = '#ffd57f'; ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
  }
  // drops
  for (const d of drops){
    ctx.fillStyle = '#f6d365'; ctx.beginPath(); ctx.ellipse(d.x,d.y,8,6,0,0,Math.PI*2); ctx.fill();
  }
  // player
  if (player) player.draw(ctx);

  // HUD
  ctx.fillStyle = '#e6eef2';
  ctx.font = '14px sans-serif';
  if (player){
    ctx.fillText('HP: ' + Math.max(0,Math.floor(player.hp)) + ' / ' + player.maxHp, 12, 20);
  }
  // resources status
  if (!resourcesLoaded) {
    ctx.fillStyle = '#fff';
    ctx.fillText('載入資源...', W/2 - 40, H/2);
  }
}

// save/load (only basic player hp & pos for demo)
function saveGame(){
  if (!player) return;
  const save = { x:player.x, y:player.y, hp:player.hp };
  localStorage.setItem('arpg_save', JSON.stringify(save));
  statusEl.textContent = '已儲存';
}
function loadGame(){
  const s = localStorage.getItem('arpg_save');
  if (!s) { statusEl.textContent = '找不到儲存'; return; }
  const data = JSON.parse(s);
  if (!player) newGame();
  player.x = data.x; player.y = data.y; player.hp = data.hp;
  statusEl.textContent = '已載入';
}

// helper: how to replace sprite sheet with your own:
// - 將 spriteImg.src 改為你的圖檔 URL，例如: spriteImg.src = 'sprites/player_sheet.png';
// - 設定 SPRITE.tileW / tileH 與 SPRITE.cols / rows 對應你的 spritesheet 格子大小
// - 修改 ANIM_CLIPS 裡的 row / start / frames / speed 來對應你圖中每個動作的位置
//   例如：若你的行走動畫在第 2 列、第 3 欄開始、共 4 格，則 {name:'walk', row:1, start:2, frames:4, speed:0.1}
//
// 注意：若圖檔有透明背景，能得到更好視覺。你可以把 demoSpriteDataURL 換成外部圖檔或內嵌的更複雜 dataURL。

</script>
</body>
</html>
