<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>俄羅斯方塊（Tetris）</title>
<style>
  :root{
    --bg:#111;
    --panel:#222;
    --accent:#2ecc71;
    --tile-size:28px;
    --cols:10;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1220,#071027);color:#eee;font-family:Inter, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:20px;box-sizing:border-box;}
  .game{
    display:grid;
    grid-template-columns: auto 180px;
    gap:16px;
    align-items:start;
    width:min(900px,96vw);
  }
  header{grid-column:1/3;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  h1{margin:0;font-size:20px;color:#fff}
  .board-wrap{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.6);display:flex;flex-direction:column;align-items:center}
  canvas{background:#071722;border-radius:6px;display:block}
  .sidebar{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;min-width:180px;box-sizing:border-box}
  .stat{margin-bottom:10px}
  .stat b{display:block;font-size:12px;color:#9fb7c6}
  .next-canvas{background:#071722;border-radius:6px;display:block;margin-top:6px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:#1f6b8e;border:none;color:#fff;padding:8px 10px;border-radius:6px;cursor:pointer}
  .hint{font-size:12px;color:#9fb7c6;margin-top:8px}
  @media(max-width:700px){
    .game{grid-template-columns: 1fr; align-items:stretch}
    .sidebar{order:2}
  }
  /* tile color */
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .legend span{display:inline-block;padding:4px 6px;border-radius:4px;background:rgba(255,255,255,0.04);font-size:12px;color:#cfe6f0}
</style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <header>
        <h1>俄羅斯方塊（Tetris）</h1>
        <div>
          <small style="color:#9fb7c6">控制：← → 移動，↑ 旋轉，↓ 加速，空白 鬆手硬下落，P 暫停</small>
        </div>
      </header>

      <div class="board-wrap">
        <canvas id="board"></canvas>
      </div>

      <aside class="sidebar">
        <div class="stat"><b>分數</b><div id="score">0</div></div>
        <div class="stat"><b>等級</b><div id="level">1</div></div>
        <div class="stat"><b>消行</b><div id="lines">0</div></div>

        <div class="stat"><b>下一個</b>
          <canvas id="next" class="next-canvas" width="120" height="120"></canvas>
        </div>

        <div class="controls">
          <button id="btnStart">Start</button>
          <button id="btnPause">Pause</button>
          <button id="btnReset">Reset</button>
        </div>

        <div class="hint">提示：按 H 可取得幫助（簡易操作說明）。</div>

        <div class="legend" aria-hidden="true">
          <span>I (青)</span><span>J (藍)</span><span>L (橙)</span><span>O (黃)</span><span>S (綠)</span><span>T (紫)</span><span>Z (紅)</span>
        </div>
      </aside>
    </div>
  </div>

<script>
/* 簡化但完整的 Tetris 實作（JS） */
const COLS = 10, ROWS = 20;
const TILE = 28; // 基本方塊尺寸（像素）
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

let grid = createEmptyGrid();
let current = null;
let nextPiece = null;
let dropInterval = 1000; // ms
let lastDrop = 0;
let score = 0;
let level = 1;
let lines = 0;
let running = false;
let paused = false;

// 音效（簡單 beep）
// 使用 WebAudio API 產生短聲效
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, duration=0.06, type='sine', gain=0.08){
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + duration);
}

// 方塊定義（4x4 matrix）
// 每個 tetromino 定義多個旋轉狀態
const PIECES = {
  I: {
    color: '#00e5ff',
    states: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ]
  },
  J: {
    color: '#0055ff',
    states: [
      [[1,0,0],[1,1,1],[0,0,0]],
      [[0,1,1],[0,1,0],[0,1,0]],
      [[0,0,0],[1,1,1],[0,0,1]],
      [[0,1,0],[0,1,0],[1,1,0]]
    ]
  },
  L: {
    color: '#ff8c00',
    states: [
      [[0,0,1],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,0],[0,1,1]],
      [[0,0,0],[1,1,1],[1,0,0]],
      [[1,1,0],[0,1,0],[0,1,0]]
    ]
  },
  O: {
    color: '#ffd400',
    states: [
      [[1,1],[1,1]]
    ]
  },
  S: {
    color: '#00c853',
    states: [
      [[0,1,1],[1,1,0],[0,0,0]],
      [[0,1,0],[0,1,1],[0,0,1]]
    ]
  },
  T: {
    color: '#9b59b6',
    states: [
      [[0,1,0],[1,1,1],[0,0,0]],
      [[0,1,0],[0,1,1],[0,1,0]],
      [[0,0,0],[1,1,1],[0,1,0]],
      [[0,1,0],[1,1,0],[0,1,0]]
    ]
  },
  Z: {
    color: '#ff1744',
    states: [
      [[1,1,0],[0,1,1],[0,0,0]],
      [[0,0,1],[0,1,1],[0,1,0]]
    ]
  }
};

const PIECE_KEYS = Object.keys(PIECES);

// 建立空的格子
function createEmptyGrid(){
  const g = [];
  for (let r=0;r<ROWS;r++){
    g.push(new Array(COLS).fill(0));
  }
  return g;
}

// 隨機取得一個 tetromino
function randomPiece(){
  const k = PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)];
  const meta = PIECES[k];
  const stateIndex = 0;
  return {
    type: k,
    states: meta.states,
    color: meta.color,
    x: Math.floor((COLS - meta.states[0][0].length)/2),
    y: - (meta.states[0].length - 1),
    r: stateIndex
  };
}

// 旋轉（從 states 取 r）
function getShape(piece){
  return piece.states[piece.r];
}

// 碰撞檢查
function collide(xOffset=0,yOffset=0, rOffset=0){
  const shape = pieceShapeWithRotation(current, rOffset);
  for (let y=0;y<shape.length;y++){
    for (let x=0;x<shape[y].length;x++){
      if (!shape[y][x]) continue;
      const gx = current.x + x + xOffset;
      const gy = current.y + y + yOffset;
      if (gx < 0 || gx >= COLS || gy >= ROWS) return true;
      if (gy >= 0 && grid[gy][gx]) return true;
    }
  }
  return false;
}
function pieceShapeWithRotation(piece, rOffset=0){
  const states = piece.states;
  const r = (piece.r + rOffset + states.length) % states.length;
  return states[r];
}

// 將方塊固定到 grid
function lockPiece(){
  const shape = getShape(current);
  for (let y=0;y<shape.length;y++){
    for (let x=0;x<shape[y].length;x++){
      if (!shape[y][x]) continue;
      const gx = current.x + x;
      const gy = current.y + y;
      if (gy < 0) {
        // game over
        gameOver();
        return;
      }
      grid[gy][gx] = { color: current.color };
    }
  }
  // 消行
  let cleared = 0;
  for (let r=ROWS-1;r>=0;r--){
    if (grid[r].every(c=>c)) {
      grid.splice(r,1);
      grid.unshift(new Array(COLS).fill(0));
      cleared++;
      r++; // recheck same row index after splice
    }
  }
  if (cleared>0){
    // 計分（傳統）
    const points = [0,40,100,300,1200];
    score += points[cleared] * level;
    lines += cleared;
    // 等級提升：每消 10 行升一級
    const newLevel = Math.floor(lines / 10) + 1;
    if (newLevel > level) {
      level = newLevel;
      // 加速
      dropInterval = Math.max(100, 1000 - (level - 1) * 80);
    }
    beep(600,0.06,'saw',0.06);
  }

  // 下一個成為 current
  current = nextPiece || randomPiece();
  nextPiece = randomPiece();
  updateStats();
  drawNext();
  // 若一放下就碰撞 -> game over handled in lockPiece when gy<0
}

// 移動與旋轉
function move(dx){
  if (!current) return;
  if (!collide(dx,0,0)) {
    current.x += dx;
  } else {
    return;
  }
}
function softDrop(){
  if (!current) return;
  if (!collide(0,1,0)) {
    current.y += 1;
  } else {
    // can't move down, lock
    lockPiece();
  }
}
function hardDrop(){
  if (!current) return;
  while(!collide(0,1,0)){
    current.y += 1;
    score += 2; // small reward for hard drop distance
  }
  lockPiece();
  beep(900,0.04,'sine',0.04);
}
function rotate(){
  if (!current) return;
  if (!collide(0,0,1)) {
    current.r = (current.r + 1) % current.states.length;
  } else {
    // simple wall kick: try left or right
    if (!collide(-1,0,1)) current.x -= 1, current.r = (current.r+1)%current.states.length;
    else if (!collide(1,0,1)) current.x += 1, current.r = (current.r+1)%current.states.length;
  }
}

// 繪製函式
function draw(){
  // canvas size 根據 TILE 與 ROWS/COLS
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;
  // scale for crispness on high DPI
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width = (COLS * TILE) + 'px';
  canvas.style.height = (ROWS * TILE) + 'px';
  if (dpr !== 1) {
    canvas.width = Math.round(COLS * TILE * dpr);
    canvas.height = Math.round(ROWS * TILE * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  } else {
    ctx.setTransform(1,0,0,1,0,0);
  }

  // 背景
  ctx.fillStyle = '#071722';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw grid cells
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const cell = grid[r][c];
      if (cell) drawTile(ctx,c* TILE, r* TILE, TILE, cell.color);
      else {
        // empty cell faint grid
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fillRect(c*TILE, r*TILE, TILE-1, TILE-1);
      }
    }
  }

  // draw current piece
  if (current) {
    const shape = getShape(current);
    for (let y=0;y<shape.length;y++){
      for (let x=0;x<shape[y].length;x++){
        if (!shape[y][x]) continue;
        const gx = current.x + x;
        const gy = current.y + y;
        if (gy >= 0) drawTile(ctx, gx*TILE, gy*TILE, TILE, current.color);
      }
    }
  }

  // draw border
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.strokeRect(0,0,canvas.width,canvas.height);
}

// tile style
function drawTile(ctx,x,y,size,color){
  // main rect
  ctx.fillStyle = color;
  roundRect(ctx, x+1, y+1, size-2, size-2, 4, true, false);

  // inner highlight
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(x+3, y+3, size-6, Math.max(4,size/4));

  // inner shading bottom
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(x+3, y+size/2, size-6, size/2 - 3);
}

function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// draw next preview
function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  nctx.fillStyle = '#071722';
  nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  if (!nextPiece) return;
  const box = 4 * TILE;
  const scale = Math.min(nextCanvas.width/box, nextCanvas.height/box);
  const ox = (nextCanvas.width - box*scale)/2;
  const oy = (nextCanvas.height - box*scale)/2;

  const shape = nextPiece.states[0];
  for (let y=0;y<shape.length;y++){
    for (let x=0;x<shape[y].length;x++){
      if (!shape[y][x]) continue;
      const px = ox + x * TILE * scale;
      const py = oy + y * TILE * scale;
      // draw small tile
      nctx.fillStyle = nextPiece.color;
      nctx.fillRect(px+1,py+1,TILE*scale-2,TILE*scale-2);
    }
  }
}

// game loop
let lastTime = 0;
function loop(ts){
  if (!running) return;
  if (paused) {
    lastTime = ts;
    requestAnimationFrame(loop);
    return;
  }
  if (!lastTime) lastTime = ts;
  const delta = ts - lastTime;
  lastTime = ts;

  lastDrop += delta;
  if (lastDrop >= dropInterval) {
    lastDrop = 0;
    softDrop();
  }
  draw();
  requestAnimationFrame(loop);
}

// game control
function startGame(){
  grid = createEmptyGrid();
  current = randomPiece();
  nextPiece = randomPiece();
  score = 0; level = 1; lines = 0;
  dropInterval = 1000;
  running = true;
  paused = false;
  lastDrop = 0;
  updateStats();
  drawNext();
  beep(400,0.06,'sine',0.05);
  requestAnimationFrame(loop);
}
function pauseGame(){
  paused = !paused;
  document.getElementById('btnPause').textContent = paused ? 'Resume' : 'Pause';
}
function resetGame(){
  running = false;
  paused = false;
  score = 0; level = 1; lines = 0;
  grid = createEmptyGrid();
  current = null; nextPiece = null;
  updateStats();
  draw();
}
function gameOver(){
  running = false;
  beep(120,0.18,'saw',0.08);
  alert('遊戲結束！分數：' + score);
}

// stats
function updateStats(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
}

// key controls
window.addEventListener('keydown',(e)=>{
  if (!running) return;
  if (e.key === 'p' || e.key === 'P') { pauseGame(); e.preventDefault(); return; }
  if (paused) return;
  if (['ArrowLeft','a','A'].includes(e.key)) { move(-1); e.preventDefault(); draw(); }
  if (['ArrowRight','d','D'].includes(e.key)) { move(1); e.preventDefault(); draw(); }
  if (['ArrowUp','w','W'].includes(e.key)) { rotate(); e.preventDefault(); draw(); }
  if (['ArrowDown','s','S'].includes(e.key)) { softDrop(); e.preventDefault(); draw(); }
  if (e.code === 'Space') { hardDrop(); e.preventDefault(); draw(); }
  if (e.key === 'h' || e.key === 'H') {
    alert('Tetris 控制：← → 移動，↑ 旋轉，↓ 加速，空白 鬆手硬下落，P 暫停\n按 Start 開始遊戲');
  }
});

// 按鈕事件
document.getElementById('btnStart').addEventListener('click', ()=>{ startGame(); });
document.getElementById('btnPause').addEventListener('click', ()=>{ pauseGame(); });
document.getElementById('btnReset').addEventListener('click', ()=>{ resetGame(); });

// init drawing baseline
draw();

// 自動縮放（視口改變時）
window.addEventListener('resize', draw);

// 小提示：若要加速（hold down 要平滑），可實作 keydown repeat handling（此示範維持簡潔）
</script>
</body>
</html>
