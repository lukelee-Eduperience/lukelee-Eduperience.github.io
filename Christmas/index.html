<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è–èª•å¿«æ¨‚æ´¾ç¦®ç‹</title>
  <style>
    :root{
      --bg:#f6fbff;
      --panel:#fff;
      --primary:#ff5c8a;
      --accent:#3bb4ff;
      --gold:#ffd54a;
      --green:#4caf50;
      --text:#1a1a1a;
      --shadow: 0 6px 18px rgba(10,20,40,0.12);
      --kid-font: "Comic Sans MS", "Comic Neue", "Segoe UI", system-ui, -apple-system, sans-serif;
    }
    html,body{height:100%;margin:0;font-family:var(--kid-font);background:linear-gradient(180deg,#e8f8ff 0%, var(--bg) 40%);color:var(--text)}
    .wrap{max-width:1100px;margin:20px auto;padding:18px;display:flex;gap:18px;align-items:flex-start}
    .game-area{flex:1;min-height:640px;background:linear-gradient(180deg,#ffffff 0%, #fffdf6 100%);border-radius:18px;box-shadow:var(--shadow);padding:14px;position:relative;overflow:hidden}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px}
    .title-badge{display:flex;align-items:center;gap:12px}
    .logo{width:72px;height:72px;border-radius:14px;background:linear-gradient(180deg,var(--primary),#ff9bbf);display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(255,92,138,0.18);color:white;font-weight:800;font-size:18px;overflow:hidden;position:relative}
    .logo img{width:100%;height:100%;object-fit:cover;display:block;filter:drop-shadow(0 6px 10px rgba(0,0,0,0.12));}
    .title{font-size:20px;line-height:1}
    .subtitle{font-size:12px;color:rgba(0,0,0,0.55)}
    .controls{display:flex;gap:10px;align-items:center}
    .panel{background:var(--panel);border-radius:12px;padding:10px 12px;box-shadow:var(--shadow);display:flex;gap:8px;align-items:center}
    .big{font-size:20px;font-weight:700;color:var(--primary)}
    .small{font-size:12px;color:rgba(0,0,0,0.6)}
    .stage{margin-top:8px;height:520px;border-radius:14px;background: linear-gradient(180deg,#e7f9ff 0%, #f8fff4 100%);border: 4px dashed rgba(0,0,0,0.03);position:relative;overflow:hidden;display:flex;align-items:flex-start;justify-content:flex-start}
    /* background image layer inside stage */
    .stage-bg{
      position:absolute;
      inset:0;
      z-index:2;
      background-position:center;
      background-size:cover;
      background-repeat:no-repeat;
      pointer-events:none;
      filter: blur(4px);
      opacity:0.5; /* 50% transparency requested */
      transform: scale(1.02); /* slight upscale to avoid edges after blur */
    }
    /* content over the background */
    .playfield{position:absolute;inset:10px 10px 10px 10px;pointer-events:auto;z-index:4}
    /* Santa (controllable) */
    .santa{
      position:absolute;
      width:120px;
      height:120px;
      border-radius:20px;
      background:linear-gradient(180deg,#ffb4a6,#ff7a6a);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;
      box-shadow:0 10px 22px rgba(0,0,0,0.12);
      cursor:grab;
      user-select:none;
      touch-action:none;
      z-index:40;
      overflow:hidden;
    }
    .santa:active{cursor:grabbing}
    .santa img { width:100%; height:100%; object-fit:cover; display:block; }
    .santa .label{position:absolute;bottom:6px;left:6px;font-weight:900;color:white;text-shadow:0 2px 6px rgba(0,0,0,0.12);font-size:12px;background:rgba(0,0,0,0.18);padding:4px 8px;border-radius:8px;}
    /* children: è¦–è¦ºä¸Šç¸®å° 40%ï¼ˆå³ 60% å°ºå¯¸ï¼‰ï¼Œä½†ç¢°æ’æ¡†ä»¥ç¸®å°å¾Œçš„å°ºå¯¸åˆ¤å®š */
    .child{
      position:absolute;
      width:84px;
      height:100px;
      border-radius:12px;
      background:linear-gradient(180deg,#fff,#fffcec);
      box-shadow:0 8px 16px rgba(20,20,60,0.08);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:8px;cursor:pointer;user-select:none;z-index:30;overflow:hidden;
      transform-origin:center center;
      /* æˆ‘å€‘æŠŠè¦–è¦ºç¸®æ”¾ 0.6ï¼Œä¾†é”æˆã€Œç¸®å°40%ã€çš„æ•ˆæœ */
      transform: scale(0.6);
    }
    .child img{width:72px;height:72px;object-fit:cover;border-radius:10px}
    .child .face{width:48px;height:48px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:20px;box-shadow:inset 0 -6px 10px rgba(0,0,0,0.08)}
    .child .label{font-size:12px;color:#333}

    /* monster */
    .monster{
      position:absolute;
      width:96px;
      height:110px;
      border-radius:12px;
      background:linear-gradient(180deg,#fff7f7,#fff1f3);
      box-shadow:0 8px 20px rgba(100,10,10,0.06);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:8px;cursor:pointer;user-select:none;z-index:32;overflow:hidden;
      transform-origin:center center;
      border:3px solid rgba(220,40,60,0.18);
      transform: scale(0.7);
    }
    .monster img{width:80px;height:80px;object-fit:contain;border-radius:8px}
    .monster .label{font-size:12px;color:#a11;font-weight:800}

    .gift{position:absolute;width:56px;height:56px;border-radius:10px;background:linear-gradient(180deg,var(--gold),#ffdb6b);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 26px rgba(0,0,0,0.18);transform-origin:center;z-index:35}
    .gift img{width:100%;height:100%;object-fit:contain;border-radius:8px}
    .sidebar{width:300px;display:flex;flex-direction:column;gap:12px}
    .card{background:var(--panel);border-radius:12px;padding:14px;box-shadow:var(--shadow)}
    .meter{height:12px;background:linear-gradient(90deg,#fff 0%, #fff 100%);border-radius:12px;overflow:hidden;border:2px solid rgba(0,0,0,0.04)}
    .meter > i{display:block;height:100%;background:linear-gradient(90deg,#ffd54a,#ff9b4f);width:0%;transition:width 300ms ease}
    .btn{display:inline-flex;gap:8px;align-items:center;justify-content:center;padding:10px 12px;border-radius:10px;cursor:pointer;border:none;font-weight:800;font-size:14px}
    .btn-primary{background:linear-gradient(180deg,var(--accent),#0ea5ff);color:white;box-shadow:0 8px 18px rgba(59,180,255,0.18)}
    .btn-ghost{background:transparent;border:2px dashed rgba(0,0,0,0.06);color:var(--text)}
    .overlay{position:absolute;inset:0;background:rgba(6,10,20,0.35);display:flex;align-items:center;justify-content:center;z-index:80;backdrop-filter:blur(2px)}
    .modal{background:white;border-radius:12px;padding:22px;box-shadow:0 18px 40px rgba(0,0,0,0.36);max-width:420px;text-align:center}
    .final-score{font-size:40px;font-weight:900;color:var(--gold);margin:12px 0}
    .tips{font-size:12px;color:rgba(0,0,0,0.6)}
    .proximityHint{
      position:absolute;
      z-index:50;
      background:rgba(255,255,255,0.95);
      border-radius:10px;
      padding:6px 10px;
      box-shadow:0 6px 18px rgba(0,0,0,0.12);
      font-size:13px;
      display:none;
    }
    .next-gift{
      display:flex;align-items:center;gap:10px;padding:10px;border-radius:12px;background:linear-gradient(180deg,#fff,#fffaf0);box-shadow:var(--shadow);
    }
    .next-gift .label{font-weight:800}
    .next-gift .preview{width:72px;height:72px;border-radius:10px;overflow:hidden;background:linear-gradient(180deg,#fff,#fff);display:flex;align-items:center;justify-content:center;border:1px solid rgba(0,0,0,0.04)}
    .next-gift .preview img{width:100%;height:100%;object-fit:contain}
    @media (max-width:960px){.wrap{padding:10px;flex-direction:column}.sidebar{width:100%}}
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="å¯æ“æ§è–èª•è€äººæ´¾ç¦®éŠæˆ² - å«æ€ªç¸">
    <div class="game-area" id="gameArea">
      <div class="hud">
        <div class="title-badge">
          <div class="logo" id="logoIcon" aria-hidden="true">
            <img id="logoImg" alt="icon" src="icon.png" onerror="this.style.display='none'">
            <div id="logoFallback" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:28px;">ğŸ…</div>
          </div>
          <div>
            <div class="title">è–èª•å¿«æ¨‚æ´¾ç¦®ç‹</div>
            <div class="subtitle">æ³¨æ„ï¼šä¸è¦æŠŠç¦®ç‰©æ´¾çµ¦æ€ªç¸ï¼</div>
          </div>
        </div>

        <div class="controls" aria-hidden="false">
          <div class="panel">
            <div style="text-align:right;">
              <div class="small">æ™‚é–“</div>
              <div class="big" id="timerDisplay">60</div>
            </div>
          </div>
          <div class="panel">
            <div style="text-align:right;">
              <div class="small">åˆ†æ•¸</div>
              <div class="big" id="scoreDisplay">0</div>
            </div>
          </div>
        </div>
      </div>

      <div class="stage" id="stage" aria-live="polite">
        <!-- background image layer (uses background3.png with 50% opacity and blur) -->
        <div class="stage-bg" id="stageBg" aria-hidden="true"></div>

        <div class="playfield" id="playfield" tabindex="0" aria-label="éŠæˆ²å€åŸŸ">
          <!-- Santa (controllable) -->
          <div class="santa" id="santa" role="application" aria-label="è–èª•è€äºº">
            <div class="label">è–èª•è€äºº</div>
          </div>

          <!-- proximity hint -->
          <div id="proximityHint" class="proximityHint">å‘å°æœ‹å‹æ´¾ç¦®ç‰©</div>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between;">
        <div class="tips">æ“ä½œï¼šæ–¹å‘éµ / WASD ç§»å‹•ï¼›æ»‘é¼ æ‹–å‹•è–èª•è€äººï¼›é è¿‘å°æœ‹å‹å¾ŒæŒ‰ç©ºç™½éµæˆ–é»æ“Šå°æœ‹å‹æ´¾ç¦®ç‰©ã€‚æ´¾çµ¦æ€ªç¸æœƒæ‰£ 5 åˆ†ã€‚</div>
        <div>
          <button class="btn btn-primary" id="startBtn">é–‹å§‹éŠæˆ²</button>
          <button class="btn btn-ghost" id="resetBtn">é‡æ–°é–‹å§‹</button>
        </div>
      </div>

      <!-- final overlay (hidden initially) -->
      <div id="finalOverlay" class="overlay" style="display:none" role="dialog" aria-modal="true">
        <div class="modal" id="finalModal">
          <div style="font-weight:900;font-size:20px">å›åˆçµæŸ</div>
          <div class="final-score" id="finalScore">0</div>
          <div id="finalMsg">è¾›è‹¦äº†ï¼å†æ¥å†å²ï¼</div>
          <div style="margin-top:14px;">
            <button class="btn btn-primary" id="playAgain">å†ç©ä¸€æ¬¡</button>
            <button class="btn btn-ghost" id="closeOverlay">é—œé–‰</button>
          </div>
        </div>
      </div>

    </div>

    <div class="sidebar">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div style="font-size:13px;color:rgba(0,0,0,0.6)">ç›®æ¨™åˆ†æ•¸</div>
            <div style="font-size:22px;font-weight:900;color:var(--green)" id="targetDisplay">200</div>
          </div>
          <div style="text-align:right;">
            <div style="font-size:13px;color:rgba(0,0,0,0.6)">æœ€é«˜åˆ†</div>
            <div style="font-size:22px;font-weight:900;color:#6b21a8" id="bestDisplay">0</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="meter" aria-hidden="true">
            <i id="progressBar" style="width:0%"></i>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:800;margin-bottom:8px;">éŠæˆ²èªªæ˜</div>
        <ol style="padding-left:18px;margin:0;">
          <li>æ¯å›åˆ 60 ç§’ï¼Œç”¨éµç›¤æˆ–æ»‘é¼ æ§åˆ¶è–èª•è€äººç§»å‹•ï¼ŒæŒ‰ç©ºç™½éµæˆ–é»æ“Šå°æœ‹å‹å˜—è©¦æ´¾ç¦®ç‰©ã€‚</li>
          <li>æ”¶åˆ°ç¦®ç‰©çš„å°æœ‹å‹æœƒé–‹å¿ƒé›¢é–‹ï¼Œæ´¾ä¸­ä¸€æ¬¡å¾— +10 åˆ†ï¼›èª¤æ´¾çµ¦æ€ªç¸æœƒ -5 åˆ†ï¼Œæ€ªç¸æœƒæ¶ˆå¤±ã€‚</li>
        </ol>
      </div>

      <div class="card" id="feedbackCard" aria-live="polite">
        <div style="font-weight:800;margin-bottom:8px;">è¨Šæ¯</div>
        <div id="feedbackText">æº–å‚™å¥½äº†å—ï¼ŸæŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ï¼</div>
      </div>

      <!-- Next gift display in the right-bottom area -->
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div class="next-gift" aria-live="polite">
            <div>
              <div class="label">ä¸‹ä¸€ä»½ç¦®ç‰©</div>
              <div style="font-size:12px;color:rgba(0,0,0,0.55)">é è¿‘å°æœ‹å‹ä¸¦æ´¾é€</div>
            </div>
            <div class="preview" id="nextGiftPreview" aria-hidden="false" title="ä¸‹ä¸€ä»½ç¦®ç‰©">
              <div id="nextGiftFallback" style="font-size:28px">ğŸ</div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Minimal audio placeholders (è«‹ä¸Šç·šæ™‚æ›¿æ›æˆå¯¦éš›éŸ³æ•ˆ) -->
  <audio id="sfxGift" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>
  <audio id="sfxHappy" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>
  <audio id="sfxFinal" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>

  <script>
    // Elements
    const playfield = document.getElementById('playfield');
    const santa = document.getElementById('santa');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const feedbackText = document.getElementById('feedbackText');
    const progressBar = document.getElementById('progressBar');
    const targetDisplay = document.getElementById('targetDisplay');
    const bestDisplay = document.getElementById('bestDisplay');
    const finalOverlay = document.getElementById('finalOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const finalMsg = document.getElementById('finalMsg');
    const playAgainBtn = document.getElementById('playAgain');
    const closeOverlay = document.getElementById('closeOverlay');
    const proximityHint = document.getElementById('proximityHint');
    const nextGiftPreview = document.getElementById('nextGiftPreview');
    const nextGiftFallback = document.getElementById('nextGiftFallback');
    const stageBg = document.getElementById('stageBg');
    const logoImg = document.getElementById('logoImg');
    const logoFallback = document.getElementById('logoFallback');

    const sfxGift = document.getElementById('sfxGift');
    const sfxHappy = document.getElementById('sfxHappy');
    const sfxFinal = document.getElementById('sfxFinal');

    // Game state
    let timeLeft = 60;
    let timer = null;
    let score = 0;
    let running = false;
    let target = 200; // ç›®æ¨™åˆ†æ•¸æ”¹ç‚º 200
    let best = 0;

    // Santa movement state
    let vel = {x:0,y:0};
    const speed = 220; // px/sec
    let keys = {left:false,right:false,up:false,down:false};
    let lastFrame = null;
    let dragging = false;
    let dragOffset = {x:0,y:0};

    // proximity threshold (distance in px to be considered "beside")
    const PROXIMITY_DIST = 200; // å·²æ›´æ–°ç‚º 200px

    // assets filenames (assumed in same folder as HTML)
    const santaImageFile = 'Santa.png';
    const kidImages = ['Boy1.png','Boy2.png','Girl1.png','Girl2.png'];
    const giftImages = ['Gift1.png','Gift2.png','Gift3.png','Gift4.png','Gift5.png'];
    const monsterImages = ['monster1.png','monster2.png','monster3.png','monster4.png'];
    const ICON_FILE = 'icon.png';
    const BACKGROUND_FILE = 'background3.png';

    // currently selected next gift (index into giftImages)
    let nextGiftIndex = 0;

    // visual scale applied to children (0.6 means 60% size, ç¸®å° 40%)
    const CHILD_VISUAL_SCALE = 0.6;

    // collision scale used for children (we use same as visual here, but it's separated soå¯ä»¥å¾®èª¿)
    const CHILD_COLLISION_SCALE = 0.6;

    // monster visual & collision scale
    const MONSTER_VISUAL_SCALE = 0.7;
    const MONSTER_COLLISION_SCALE = 0.7;

    // how long a child will wait before leaving if not gifted (ms)
    const CHILD_WAIT_BEFORE_LEAVE_MS = 5000;

    // how long a monster will auto-disappear (ms)
    const MONSTER_AUTO_DISAPPEAR_MS = 10000; // 10 ç§’

    // penalty for gifting a monster
    const MONSTER_PENALTY = 5;

    // utility random
    function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    // load logo icon: if icon.png exists, show it; otherwise keep fallback emoji
    function tryLoadLogo(){
      const img = new Image();
      img.onload = ()=>{
        logoImg.style.display = 'block';
        logoFallback.style.display = 'none';
      };
      img.onerror = ()=>{
        logoImg.style.display = 'none';
        logoFallback.style.display = 'flex';
      };
      img.src = ICON_FILE;
    }

    // set stage background image with 50% opacity and blur via CSS (stage-bg element)
    function tryLoadStageBackground(){
      const img = new Image();
      img.onload = ()=>{
        stageBg.style.backgroundImage = `url('${BACKGROUND_FILE}')`;
        stageBg.style.display = 'block';
      };
      img.onerror = ()=>{
        stageBg.style.backgroundImage = 'none';
        stageBg.style.display = 'none';
      };
      img.src = BACKGROUND_FILE;
    }

    // try to insert santa image if available
    function tryLoadSantaImage(){
      const img = new Image();
      img.onload = ()=> {
        santa.innerHTML = '';
        img.alt = 'Santa';
        santa.appendChild(img);
        const label = document.createElement('div'); label.className='label'; label.textContent='è–èª•è€å…¬å…¬';
        santa.appendChild(label);
      };
      img.onerror = ()=> {
        // keep existing fallback (label)
      };
      img.src = santaImageFile;
    }

    // Place santa in starting position
    function resetSantaPosition(){
      const pfW = playfield.clientWidth, pfH = playfield.clientHeight;
      santa.style.left = Math.max(20, pfW/6) + 'px';
      santa.style.top = Math.max(20, pfH - 160) + 'px';
    }

    // Helper: compute collision box center and radius for an element
    // We'll represent collision area as a circle (center x,y relative to playfield, radius)
    function getCollisionCircleForElement(el, options = {}) {
      const rect = el.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const scale = options.scale ?? 1.0;
      const cx = rect.left - pfRect.left + rect.width/2;
      const cy = rect.top - pfRect.top + rect.height/2;
      const radius = ( (rect.width + rect.height) / 4 ) * scale;
      return { x: cx, y: cy, r: radius };
    }

    // helper to schedule auto-leave for a child element
    function scheduleChildAutoLeave(childEl){
      cancelChildAutoLeave(childEl);
      const timeoutId = setTimeout(()=>{
        if(!childEl.isConnected) return;
        if(childEl.dataset.leaving === '1') return;
        childEl.dataset.leaving = '1';
        if(running) feedbackText.textContent = 'æ´¾ç¦®ç‰©çµ¦å°æœ‹å‹å§ï¼';
        childEl.animate([{opacity:1},{opacity:0}],{duration:700,easing:'ease-in'});
        setTimeout(()=>{
          try{ childEl.remove(); }catch(e){}
          setTimeout(()=>{ if(running) spawnNewChild(); }, 600);
        }, 720);
      }, CHILD_WAIT_BEFORE_LEAVE_MS);
      childEl._autoLeaveTimeout = timeoutId;
    }

    function cancelChildAutoLeave(childEl){
      if(childEl && childEl._autoLeaveTimeout){
        clearTimeout(childEl._autoLeaveTimeout);
        childEl._autoLeaveTimeout = null;
      }
    }

    // schedule monster auto-disappear
    function scheduleMonsterAutoDisappear(monEl){
      cancelMonsterAutoDisappear(monEl);
      const to = setTimeout(()=>{
        if(!monEl.isConnected) return;
        monEl.dataset.disappearing = '1';
        monEl.animate([{opacity:1},{opacity:0}],{duration:600,easing:'ease-in'});
        setTimeout(()=>{ try{ monEl.remove(); }catch(e){}; if(running) spawnNewMonster(); }, 620);
      }, MONSTER_AUTO_DISAPPEAR_MS);
      monEl._autoDisappear = to;
    }

    function cancelMonsterAutoDisappear(monEl){
      if(monEl && monEl._autoDisappear){
        clearTimeout(monEl._autoDisappear);
        monEl._autoDisappear = null;
      }
    }

    // Spawn N children randomly (ensuring non-overlap with monsters)
    function spawnChildren(count = 8){
      // remove children only (monsters handled separately)
      Array.from(playfield.querySelectorAll('.child')).forEach(n=>{
        cancelChildAutoLeave(n);
        n.remove();
      });

      const w = playfield.clientWidth;
      const h = playfield.clientHeight;
      const padding = 20;
      const positions = [];
      const existing = []; // hold existing circles (monsters + children) to avoid overlap
      // include santa as occupied
      try{ existing.push(getCollisionCircleForElement(santa, { scale: 1.0 })); }catch(e){}

      // also include existing monsters in avoidance list
      Array.from(playfield.querySelectorAll('.monster')).forEach(m=>{
        const rect = m.getBoundingClientRect();
        const pfRect = playfield.getBoundingClientRect();
        const cx = rect.left - pfRect.left + rect.width/2;
        const cy = rect.top - pfRect.top + rect.height/2;
        const r = ((rect.width + rect.height)/4) * MONSTER_COLLISION_SCALE;
        existing.push({ x: cx, y: cy, r });
      });

      for(let i=0;i<count;i++){
        let x,y,attempt=0;
        let childWidth = 84, childHeight = 100;
        const childRadius = ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE;
        do{
          x = padding + Math.random()*(w - padding*2 - childWidth);
          y = padding + Math.random()*(h - padding*2 - childHeight);
          attempt++;
          const cx = x + childWidth/2;
          const cy = y + childHeight/2;
          let ok = true;
          for(const p of existing){
            const dx = p.x - cx;
            const dy = p.y - cy;
            const minDist = (p.r + childRadius) + 12;
            if(Math.hypot(dx,dy) < minDist){ ok = false; break; }
          }
          if(ok){
            existing.push({ x: cx, y: cy, r: childRadius });
            break;
          }
        }while(attempt < 120);
        if(attempt >= 120) {
          // fallback: place anyway
          x = padding + i*6;
          y = padding + i*6;
          existing.push({ x: x + childWidth/2, y: y + childHeight/2, r: childRadius});
        }
      }

      // Now create children from the computed existing list but skip the initial entries that are not children
      // We extract last `count` entries from existing that correspond to children.
      // Simpler: re-generate children by trying to place them again using similar logic but now guaranteed separation.
      for(let i=0;i<count;i++){
        let x,y,attempt=0;
        let childWidth = 84, childHeight = 100;
        const childRadius = ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE;
        do{
          x = padding + Math.random()*(w - padding*2 - childWidth);
          y = padding + Math.random()*(h - padding*2 - childHeight);
          attempt++;
          const cx = x + childWidth/2;
          const cy = y + childHeight/2;
          let ok = true;
          // check against santa
          const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });
          if(Math.hypot(santaCircle.x - cx, santaCircle.y - cy) < (santaCircle.r + childRadius + 20)) ok = false;
          // check against existing monsters and already placed children
          Array.from(playfield.querySelectorAll('.monster')).forEach(m=>{
            const rect = m.getBoundingClientRect();
            const pfRect = playfield.getBoundingClientRect();
            const mcx = rect.left - pfRect.left + rect.width/2;
            const mcy = rect.top - pfRect.top + rect.height/2;
            const mr = ((rect.width + rect.height)/4) * MONSTER_COLLISION_SCALE;
            if(Math.hypot(mcx - cx, mcy - cy) < (mr + childRadius + 12)) ok = false;
          });
          Array.from(playfield.querySelectorAll('.child')).forEach(c=>{
            const rect = c.getBoundingClientRect();
            const pfRect = playfield.getBoundingClientRect();
            const ocx = rect.left - pfRect.left + rect.width/2;
            const ocy = rect.top - pfRect.top + rect.height/2;
            const or = ((rect.width + rect.height)/4) * CHILD_COLLISION_SCALE;
            if(Math.hypot(ocx - cx, ocy - cy) < (or + childRadius + 12)) ok = false;
          });
          if(ok) break;
        }while(attempt < 160);
        const el = document.createElement('div');
        el.className = 'child';
        el.setAttribute('role','button');
        el.setAttribute('tabindex','0');

        const img = new Image();
        const pick = kidImages[rand(0,kidImages.length-1)];
        img.src = pick;
        img.alt = 'å°æœ‹å‹';
        img.onload = ()=>{
          while(el.firstChild) el.removeChild(el.firstChild);
          img.style.width = '72px';
          img.style.height = '72px';
          el.appendChild(img);
          const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
          el.appendChild(label);
        };
        img.onerror = ()=>{
          while(el.firstChild) el.removeChild(el.firstChild);
          const face = document.createElement('div'); face.className='face'; face.textContent = ['ğŸ™‚','ğŸ˜Š','ğŸ˜„','ğŸ˜‹'][rand(0,3)];
          const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
          el.appendChild(face); el.appendChild(label);
        };

        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.dataset.collisionScale = String(CHILD_COLLISION_SCALE);
        el.style.transform = `scale(${CHILD_VISUAL_SCALE})`;
        el.dataset.leaving = '0';

        el.addEventListener('click', (ev)=>{
          if(!running) return;
          attemptGiftTo(el);
        });

        playfield.appendChild(el);
        if(running) scheduleChildAutoLeave(el);
      }

      // Ensure there are some monsters present as well
      // If none exist, spawn default 4 monsters
      const existingMonsters = playfield.querySelectorAll('.monster').length;
      if(existingMonsters === 0){
        spawnMonsters(4);
      }
    }

    function spawnMonsters(count = 4){
      // We will place monsters ensuring they do not overlap with existing children or santa
      const w = playfield.clientWidth;
      const h = playfield.clientHeight;
      const padding = 20;
      const placed = [];

      for(let i=0;i<count;i++){
        let x,y,attempt=0;
        const monW = 96, monH = 110;
        const monR = ((monW + monH) / 4) * MONSTER_COLLISION_SCALE;
        do{
          x = padding + Math.random()*(w - padding*2 - monW);
          y = padding + Math.random()*(h - padding*2 - monH);
          attempt++;
          const cx = x + monW/2;
          const cy = y + monH/2;
          let ok = true;
          // avoid santa
          const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });
          if(Math.hypot(santaCircle.x - cx, santaCircle.y - cy) < (santaCircle.r + monR + 30)) ok = false;
          // avoid existing placed monsters
          for(const p of placed){
            if(Math.hypot(p.cx - cx, p.cy - cy) < (p.r + monR + 14)){ ok = false; break; }
          }
          // avoid existing children on playfield
          Array.from(playfield.querySelectorAll('.child')).forEach(c=>{
            const rect = c.getBoundingClientRect();
            const pfRect = playfield.getBoundingClientRect();
            const ccx = rect.left - pfRect.left + rect.width/2;
            const ccy = rect.top - pfRect.top + rect.height/2;
            const cr = ((rect.width + rect.height)/4) * CHILD_COLLISION_SCALE;
            if(Math.hypot(ccx - cx, ccy - cy) < (cr + monR + 14)) ok = false;
          });
          if(ok) break;
        }while(attempt < 120);
        if(attempt >= 120){
          // if couldn't find perfect spot, try again with looser constraints
          x = padding + Math.random()*(w - padding*2 - monW);
          y = padding + Math.random()*(h - padding*2 - monH);
        }
        const pos = { x, y, cx: x + monW/2, cy: y + monH/2, r: monR };
        placed.push(pos);
      }

      placed.forEach(pos=>{
        const el = document.createElement('div');
        el.className = 'monster';
        el.setAttribute('role','button');
        el.setAttribute('tabindex','0');

        const img = new Image();
        const pick = monsterImages[rand(0,monsterImages.length-1)];
        img.src = pick;
        img.alt = 'æ€ªç¸';
        img.onload = ()=>{
          while(el.firstChild) el.removeChild(el.firstChild);
          img.style.width = '80px';
          img.style.height = '80px';
          el.appendChild(img);
          const label = document.createElement('div'); label.className='label'; label.textContent='æ€ªç¸';
          el.appendChild(label);
        };
        img.onerror = ()=>{
          while(el.firstChild) el.removeChild(el.firstChild);
          const face = document.createElement('div'); face.className='face'; face.textContent = ['ğŸ‘¾','ğŸ˜ˆ','ğŸ‘¹','ğŸ‘º'][rand(0,3)];
          face.style.background = 'linear-gradient(90deg,#ff6b6b,#ffb86b)';
          const label = document.createElement('div'); label.className='label'; label.textContent='æ€ªç¸';
          el.appendChild(face); el.appendChild(label);
        };

        el.style.left = pos.x + 'px';
        el.style.top = pos.y + 'px';
        el.dataset.collisionScale = String(MONSTER_COLLISION_SCALE);
        el.style.transform = `scale(${MONSTER_VISUAL_SCALE})`;
        el.dataset.disappearing = '0';

        // clicking monster triggers penalty (and now monster will disappear)
        el.addEventListener('click', (ev)=>{
          if(!running) return;
          attemptGiftTo(el);
        });

        playfield.appendChild(el);
        // schedule auto disappear
        scheduleMonsterAutoDisappear(el);
      });
    }

    // spawn a single monster (used when replacing auto-removed ones)
    function spawnNewMonster(){
      spawnMonsters(1);
    }

    // Attempt to give gift to target (child or monster)
    function attemptGiftTo(targetEl){
      if(!targetEl || !running) return;

      // compute centers and edge distance
      const sRect = santa.getBoundingClientRect();
      const tRect = targetEl.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const sx = sRect.left - pfRect.left + sRect.width/2;
      const sy = sRect.top - pfRect.top + sRect.height/2;
      const tx = tRect.left - pfRect.left + tRect.width/2;
      const ty = tRect.top - pfRect.top + tRect.height/2;
      const centerDist = Math.hypot(sx - tx, sy - ty);
      const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });

      // decide scale based on class (child or monster)
      let targetScale = CHILD_COLLISION_SCALE;
      if(targetEl.classList.contains('monster')) targetScale = MONSTER_COLLISION_SCALE;
      const targetCircle = getCollisionCircleForElement(targetEl, { scale: targetScale });

      const edgeDistance = Math.max(0, centerDist - santaCircle.r - targetCircle.r);

      if(edgeDistance <= PROXIMITY_DIST){
        // close enough: if monster => penalty and monster disappears, else deliver gift
        if(targetEl.classList.contains('monster')){
          penalizeForMonster(targetEl, true); // pass true to remove monster
        } else {
          deliverGift(targetEl);
        }
      } else {
        showProximityHint('å†é è¿‘ä¸€é»æ‰èƒ½æ´¾ç¦®ç‰©å–”ï¼');
      }
    }

    // Deliver gift to child (same as before)
    function deliverGift(kidEl){
      if(kidEl.dataset.leaving === '1') return;
      cancelChildAutoLeave(kidEl);
      kidEl.dataset.leaving = '1';
      try{ sfxGift.currentTime = 0; sfxGift.play(); }catch(e){}
      const kidRect = kidEl.getBoundingClientRect();
      const santaRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();

      const flying = document.createElement('div');
      flying.className = 'gift';
      flying.style.left = (santaRect.left - pfRect.left + santaRect.width/2 - 28) + 'px';
      flying.style.top = (santaRect.top - pfRect.top + santaRect.height/2 - 28) + 'px';
      const giftImg = new Image();
      giftImg.src = giftImages[nextGiftIndex];
      giftImg.alt = 'gift';
      giftImg.onload = ()=> { flying.appendChild(giftImg); };
      giftImg.onerror = ()=> { flying.textContent = 'ğŸ'; flying.style.fontSize='28px'; flying.style.display='flex'; flying.style.alignItems='center'; flying.style.justifyContent='center'; };
      playfield.appendChild(flying);

      const toX = kidRect.left - pfRect.left + kidRect.width/2 - 28;
      const toY = kidRect.top - pfRect.top + kidRect.height/2 - 28;
      flying.animate([
        { transform: 'translate(0,0) scale(1)', opacity:1 },
        { transform: `translate(${toX - (santaRect.left - pfRect.left + santaRect.width/2 - 28)}px, ${toY - (santaRect.top - pfRect.top + santaRect.height/2 - 28)}px) scale(0.8)`, opacity:1 },
        { transform: `translate(${toX - (santaRect.left - pfRect.left + santaRect.width/2 - 28)}px, ${toY - (santaRect.top - pfRect.top + santaRect.height/2 - 28)}px) scale(0.4)`, opacity:0.0 }
      ], { duration: 700, easing: 'ease-in' });

      setTimeout(()=>{ try{ flying.remove(); }catch(e){} }, 800);

      const heart = document.createElement('div');
      heart.style.position='absolute';
      heart.style.left = (kidRect.left - pfRect.left + kidRect.width/2 - 18) + 'px';
      heart.style.top = (kidRect.top - pfRect.top - 10) + 'px';
      heart.style.fontSize='28px';
      heart.style.pointerEvents='none';
      heart.style.zIndex='45';
      heart.textContent = 'ğŸ’–';
      playfield.appendChild(heart);
      heart.animate([{transform:'translateY(0px) scale(0.8)', opacity:0},{transform:'translateY(-18px) scale(1.1)', opacity:1},{transform:'translateY(-40px) scale(1.0)', opacity:0}],{duration:900,easing:'ease-out'});
      setTimeout(()=>heart.remove(),900);

      kidEl.animate([{opacity:1},{opacity:0}],{duration:700,easing:'ease-in'});
      try{ sfxHappy.currentTime = 0; sfxHappy.play(); }catch(e){}
      score += 10;
      updateScoreUI();
      feedbackText.textContent = 'æ´¾æˆåŠŸï¼å°æœ‹å‹å¥½é–‹å¿ƒï¼ +10 åˆ†';

      setTimeout(()=>{
        try{ kidEl.remove(); }catch(e){}
        setTimeout(()=>spawnNewChild(), 600);
      }, 720);

      pickNextGift();
    }

    // Penalize when giving gift to monster; if removeMonster true, monster will disappear
    function penalizeForMonster(monEl, removeMonster = false){
      // play sound
      try{ sfxGift.currentTime = 0; sfxGift.play(); }catch(e){}
      // visual feedback: monster shakes / flashes red
      monEl.animate([
        { transform: `scale(${MONSTER_VISUAL_SCALE}) translateX(0)`, boxShadow: '0 8px 20px rgba(100,10,10,0.06)' },
        { transform: `scale(${MONSTER_VISUAL_SCALE}) translateX(-8px)`, boxShadow: '0 12px 26px rgba(150,10,10,0.12)' },
        { transform: `scale(${MONSTER_VISUAL_SCALE}) translateX(8px)`, boxShadow: '0 12px 26px rgba(150,10,10,0.12)' },
        { transform: `scale(${MONSTER_VISUAL_SCALE}) translateX(0)`, boxShadow: '0 8px 20px rgba(100,10,10,0.06)' }
      ], { duration: 500, easing: 'ease-in-out' });

      // flash red overlay
      const flash = document.createElement('div');
      flash.style.position='absolute';
      const r = monEl.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      flash.style.left = (r.left - pfRect.left) + 'px';
      flash.style.top = (r.top - pfRect.top) + 'px';
      flash.style.width = r.width + 'px';
      flash.style.height = r.height + 'px';
      flash.style.borderRadius = getComputedStyle(monEl).borderRadius || '12px';
      flash.style.background = 'rgba(255,80,80,0.3)';
      flash.style.zIndex = 60;
      flash.style.pointerEvents = 'none';
      playfield.appendChild(flash);
      flash.animate([{opacity:0.9},{opacity:0}],{duration:600,easing:'ease-out'});
      setTimeout(()=>flash.remove(),620);

      // apply penalty
      score -= MONSTER_PENALTY;
      updateScoreUI();
      feedbackText.textContent = `èª¤æ´¾çµ¦æ€ªç¸ï¼-${MONSTER_PENALTY} åˆ†`;

      // monsters now disappear when gifted to
      if(removeMonster){
        cancelMonsterAutoDisappear(monEl);
        monEl.dataset.disappearing = '1';
        monEl.animate([{opacity:1},{opacity:0}],{duration:500,easing:'ease-in'});
        setTimeout(()=>{ try{ monEl.remove(); }catch(e){}; if(running) spawnNewMonster(); }, 520);
      }
    }

    function spawnNewChild(){
      const w = playfield.clientWidth;
      const h = playfield.clientHeight;
      const padding = 20;
      let x,y,attempt=0;
      let childWidth = 84, childHeight = 100;
      const childRadius = ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE;
      const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });

      do{
        x = padding + Math.random()*(w - padding*2 - childWidth);
        y = padding + Math.random()*(h - padding*2 - childHeight);
        attempt++;
        const cx = x + childWidth/2;
        const cy = y + childHeight/2;
        if(Math.hypot(cx - santaCircle.x, cy - santaCircle.y) < (santaCircle.r + childRadius + 30)) continue;
        let overlap = false;
        Array.from(playfield.querySelectorAll('.child')).forEach(c=>{
          const rect = c.getBoundingClientRect();
          const otherCx = rect.left - playfield.getBoundingClientRect().left + rect.width/2;
          const otherCy = rect.top - playfield.getBoundingClientRect().top + rect.height/2;
          const otherR = ((rect.width + rect.height)/4) * CHILD_COLLISION_SCALE;
          if(Math.hypot(cx - otherCx, cy - otherCy) < (otherR + childRadius + 10)) overlap = true;
        });
        Array.from(playfield.querySelectorAll('.monster')).forEach(m=>{
          const rect = m.getBoundingClientRect();
          const otherCx = rect.left - playfield.getBoundingClientRect().left + rect.width/2;
          const otherCy = rect.top - playfield.getBoundingClientRect().top + rect.height/2;
          const otherR = ((rect.width + rect.height)/4) * MONSTER_COLLISION_SCALE;
          if(Math.hypot(cx - otherCx, cy - otherCy) < (otherR + childRadius + 12)) overlap = true;
        });
        if(overlap) continue;
        break;
      }while(attempt < 80);
      const el = document.createElement('div');
      el.className = 'child';
      el.setAttribute('role','button');
      el.setAttribute('tabindex','0');

      const img = new Image();
      const pick = kidImages[rand(0,kidImages.length-1)];
      img.src = pick;
      img.alt = 'å°æœ‹å‹';
      img.onload = ()=>{
        while(el.firstChild) el.removeChild(el.firstChild);
        img.style.width = '72px';
        img.style.height = '72px';
        el.appendChild(img);
        const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
        el.appendChild(label);
      };
      img.onerror = ()=>{
        while(el.firstChild) el.removeChild(el.firstChild);
        const face = document.createElement('div'); face.className='face'; face.textContent = ['ğŸ™‚','ğŸ˜Š','ğŸ˜„','ğŸ˜‹'][rand(0,3)];
        const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
        el.appendChild(face); el.appendChild(label);
      };

      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.dataset.collisionScale = String(CHILD_COLLISION_SCALE);
      el.style.transform = `scale(${CHILD_VISUAL_SCALE})`;
      el.dataset.leaving = '0';
      el.addEventListener('click', (ev)=>{
        if(!running) return;
        attemptGiftTo(el);
      });
      playfield.appendChild(el);
      if(running) scheduleChildAutoLeave(el);
    }

    // compute center distance between two elements
    function distanceBetweenElementsCenter(a,b){
      const af = a.getBoundingClientRect();
      const bf = b.getBoundingClientRect();
      const pf = playfield.getBoundingClientRect();
      const ax = af.left - pf.left + af.width/2;
      const ay = af.top - pf.top + af.height/2;
      const bx = bf.left - pf.left + bf.width/2;
      const by = bf.top - pf.top + bf.height/2;
      return Math.hypot(ax - bx, ay - by);
    }

    // show temporary hint near santa
    let hintTimer = null;
    function showProximityHint(text){
      proximityHint.textContent = text;
      const sRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const left = sRect.left - pfRect.left + sRect.width/2 - 80;
      const top = sRect.top - pfRect.top - 46;
      proximityHint.style.left = Math.max(6, Math.min(playfield.clientWidth - 160, left)) + 'px';
      proximityHint.style.top = Math.max(6, top) + 'px';
      proximityHint.style.display = 'block';
      proximityHint.style.opacity = '1';
      if(hintTimer) clearTimeout(hintTimer);
      hintTimer = setTimeout(()=>{ proximityHint.style.display = 'none'; }, 1200);
    }

    // Update score UI
    function updateScoreUI(){
      scoreDisplay.textContent = score;
      const pct = Math.min(100, Math.max(0, Math.round((score/target)*100)));
      progressBar.style.width = pct + '%';
      if(score > best){ best = score; bestDisplay.textContent = best; }
    }

    // pick next gift randomly and update preview UI
    function pickNextGift(){
      nextGiftIndex = rand(0, giftImages.length - 1);
      nextGiftPreview.innerHTML = '';
      nextGiftFallback.style.display = 'none';
      const img = new Image();
      img.onload = ()=>{
        img.alt = 'ä¸‹ä¸€ä»½ç¦®ç‰©';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'contain';
        nextGiftPreview.appendChild(img);
      };
      img.onerror = ()=>{
        nextGiftFallback.style.display = 'block';
        nextGiftFallback.textContent = 'ğŸ';
      };
      img.src = giftImages[nextGiftIndex];
    }

    // Timer and game flow
    function startGame(){
      if(running) return;
      score = 0; updateScoreUI();
      timeLeft = 60; timerDisplay.textContent = timeLeft;
      running = true;
      spawnChildren(8); // includes monsters spawn if none present
      resetSantaPosition();
      pickNextGift();
      feedbackText.textContent = 'å›åˆé–‹å§‹ï¼é è¿‘å°æœ‹å‹ä¸¦æ´¾ç¦®ç‰©å§ï¼å°å¿ƒæ€ªç¸ï¼';
      lastFrame = performance.now();
      requestAnimationFrame(frameLoop);
      timer = setInterval(()=>{
        timeLeft--;
        timerDisplay.textContent = timeLeft;
        if(timeLeft <= 0) endGame();
      },1000);
    }

    function endGame(){
      if(!running) return;
      running = false;
      clearInterval(timer);
      Array.from(playfield.querySelectorAll('.child')).forEach(c=> cancelChildAutoLeave(c));
      Array.from(playfield.querySelectorAll('.monster')).forEach(m=> cancelMonsterAutoDisappear(m));
      feedbackText.textContent = `æ™‚é–“åˆ°ï¼æœ¬å›åˆåˆ†æ•¸ï¼š${score} åˆ†`;
      finalScoreEl.textContent = score;
      finalMsg.textContent = score >= target ? 'å¤ªæ£’äº†ï¼é”æˆç›®æ¨™ï¼' : 'åŠ æ²¹ï¼Œä¸‹æ¬¡ä¸€å®šå¯ä»¥æ›´é«˜åˆ†ï¼';
      try{ sfxFinal.currentTime = 0; sfxFinal.play(); }catch(e){}
      finalOverlay.style.display = 'flex';
    }

    function resetGame(){
      clearInterval(timer);
      running = false;
      Array.from(playfield.querySelectorAll('.child')).forEach(c=> cancelChildAutoLeave(c));
      Array.from(playfield.querySelectorAll('.monster')).forEach(m=> cancelMonsterAutoDisappear(m));
      timeLeft = 60; timerDisplay.textContent = timeLeft;
      score = 0; updateScoreUI();
      // clear playfield children and monsters then respawn initial set
      Array.from(playfield.querySelectorAll('.child, .monster')).forEach(n=> n.remove());
      spawnChildren(8);
      resetSantaPosition();
      pickNextGift();
      feedbackText.textContent = 'å·²é‡æ–°é–‹å§‹ï¼ŒæŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ï¼';
      finalOverlay.style.display = 'none';
    }

    // Frame loop: movement
    function frameLoop(now){
      if(!lastFrame) lastFrame = now;
      const dtMs = now - lastFrame;
      const dt = dtMs / 1000;
      lastFrame = now;

      let mvX = 0, mvY = 0;
      if(keys.left) mvX -= 1;
      if(keys.right) mvX += 1;
      if(keys.up) mvY -= 1;
      if(keys.down) mvY += 1;
      const mag = Math.hypot(mvX,mvY);
      if(mag > 0){
        mvX = mvX / mag;
        mvY = mvY / mag;
      }
      if(running || Object.values(keys).some(v=>v)){
        const curLeft = parseFloat(getComputedStyle(santa).left);
        const curTop = parseFloat(getComputedStyle(santa).top);
        const nx = curLeft + mvX * speed * dt;
        const ny = curTop + mvY * speed * dt;
        const pfW = playfield.clientWidth;
        const pfH = playfield.clientHeight;
        const sW = santa.clientWidth;
        const sH = santa.clientHeight;
        santa.style.left = Math.max(0, Math.min(pfW - sW, nx)) + 'px';
        santa.style.top = Math.max(0, Math.min(pfH - sH, ny)) + 'px';
      }

      if(running) requestAnimationFrame(frameLoop);
    }

    // Keyboard handling
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
      if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
      if(e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
      if(e.code === 'Space'){
        e.preventDefault();
        if(!running) return;
        const nearest = chooseNearestEntityForSanta();
        if(nearest) attemptGiftTo(nearest);
      }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
      if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      if(e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
    });

    // Choose nearest entity (child or monster) to santa
    function chooseNearestEntityForSanta(){
      const entities = Array.from(playfield.querySelectorAll('.child, .monster'));
      if(entities.length === 0) return null;
      const sRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const sx = sRect.left - pfRect.left + sRect.width/2;
      const sy = sRect.top - pfRect.top + sRect.height/2;
      let minD = Infinity; let pick = null;
      entities.forEach(k=>{
        const r = k.getBoundingClientRect();
        const x = r.left - pfRect.left + r.width/2;
        const y = r.top - pfRect.top + r.height/2;
        const d = Math.hypot(x-sx,y-sy);
        if(d < minD){ minD = d; pick = k; }
      });
      return pick;
    }

    // Mouse drag handling for santa
    santa.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      dragging = true;
      santa.setPointerCapture(e.pointerId);
      const rect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
    });
    santa.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const pfRect = playfield.getBoundingClientRect();
      let x = e.clientX - pfRect.left - dragOffset.x;
      let y = e.clientY - pfRect.top - dragOffset.y;
      x = Math.max(0, Math.min(playfield.clientWidth - santa.clientWidth, x));
      y = Math.max(0, Math.min(playfield.clientHeight - santa.clientHeight, y));
      santa.style.left = x + 'px';
      santa.style.top = y + 'px';
    });
    santa.addEventListener('pointerup', (e)=>{
      dragging = false;
      try{ santa.releasePointerCapture(e.pointerId); }catch(e){}
    });
    santa.addEventListener('pointercancel', ()=>{ dragging=false; });

    // Start / reset / overlay handlers
    startBtn.addEventListener('click', ()=>startGame());
    resetBtn.addEventListener('click', ()=>resetGame());
    playAgainBtn.addEventListener('click', ()=>{ finalOverlay.style.display = 'none'; resetGame(); startGame(); });
    closeOverlay.addEventListener('click', ()=>{ finalOverlay.style.display = 'none'; });

    // save best score
    try{
      const saved = localStorage.getItem('santa_proximity_best');
      if(saved){ best = parseInt(saved); bestDisplay.textContent = best; }
    }catch(e){}
    setInterval(()=>{ try{ localStorage.setItem('santa_proximity_best', String(best)); }catch(e){} }, 2000);

    // initial spawn & position
    window.addEventListener('load', ()=>{
      tryLoadLogo();
      tryLoadStageBackground();
      tryLoadSantaImage();
      // clear existing then spawn
      Array.from(playfield.querySelectorAll('.child, .monster')).forEach(n=> n.remove());
      spawnChildren(8);
      resetSantaPosition();
      pickNextGift();
    });

    // click background to focus for keyboard
    playfield.addEventListener('click', ()=>playfield.focus());

    // keep santa inside on resize
    window.addEventListener('resize', ()=>{
      const pfW = playfield.clientWidth, pfH = playfield.clientHeight;
      const curLeft = parseFloat(getComputedStyle(santa).left);
      const curTop = parseFloat(getComputedStyle(santa).top);
      santa.style.left = Math.max(0, Math.min(pfW - santa.clientWidth, curLeft)) + 'px';
      santa.style.top = Math.max(0, Math.min(pfH - santa.clientHeight, curTop)) + 'px';
    });

    // unlock audio on user gesture
    document.addEventListener('click', function unlockAudio(){
      try{
        sfxGift.volume = 0.9; sfxHappy.volume = 0.9; sfxFinal.volume = 0.9;
        sfxGift.play().then(()=>sfxGift.pause()).catch(()=>{});
        sfxHappy.play().then(()=>sfxHappy.pause()).catch(()=>{});
        sfxFinal.play().then(()=>sfxFinal.pause()).catch(()=>{});
      }catch(e){}
      document.removeEventListener('click', unlockAudio);
    });

  </script>
</body>
</html>
