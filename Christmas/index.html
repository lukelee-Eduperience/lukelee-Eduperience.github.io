<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Santa Claus is coming to town</title>
  <style>
    :root{
      --bg:#f6fbff;
      --panel:#fff;
      --primary:#ff5c8a;
      --accent:#3bb4ff;
      --gold:#ffd54a;
      --green:#4caf50;
      --text:#1a1a1a;
      --shadow: 0 6px 18px rgba(10,20,40,0.12);
      --kid-font: "Comic Sans MS", "Comic Neue", "Segoe UI", system-ui, -apple-system, sans-serif;
    }
    html,body{height:100%;margin:0;font-family:var(--kid-font);background:linear-gradient(180deg,#e8f8ff 0%, var(--bg) 40%);color:var(--text)}
    .wrap{max-width:1100px;margin:20px auto;padding:18px;display:flex;gap:18px;align-items:flex-start}
    .game-area{flex:1;min-height:640px;background:linear-gradient(180deg,#ffffff 0%, #fffdf6 100%);border-radius:18px;box-shadow:var(--shadow);padding:14px;position:relative;overflow:hidden}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px}
    .title-badge{display:flex;align-items:center;gap:12px}
    .logo{width:72px;height:72px;border-radius:14px;background:linear-gradient(180deg,var(--primary),#ff9bbf);display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(255,92,138,0.18);color:white;font-weight:800;font-size:18px}
    .title{font-size:20px;line-height:1}
    .subtitle{font-size:12px;color:rgba(0,0,0,0.55)}
    .controls{display:flex;gap:10px;align-items:center}
    .panel{background:var(--panel);border-radius:12px;padding:10px 12px;box-shadow:var(--shadow);display:flex;gap:8px;align-items:center}
    .big{font-size:20px;font-weight:700;color:var(--primary)}
    .small{font-size:12px;color:rgba(0,0,0,0.6)}
    .stage{margin-top:8px;height:520px;border-radius:14px;background: linear-gradient(180deg,#e7f9ff 0%, #f8fff4 100%);border: 4px dashed rgba(0,0,0,0.03);position:relative;overflow:hidden;display:flex;align-items:flex-start;justify-content:flex-start}
    /* Santa (controllable) */
    .santa{
      position:absolute;
      width:120px;
      height:120px;
      border-radius:20px;
      background:linear-gradient(180deg,#ffb4a6,#ff7a6a);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;
      box-shadow:0 10px 22px rgba(0,0,0,0.12);
      cursor:grab;
      user-select:none;
      touch-action:none;
      z-index:40;
      overflow:hidden;
    }
    .santa:active{cursor:grabbing}
    .santa img { width:100%; height:100%; object-fit:cover; display:block; }
    .santa .label{position:absolute;bottom:6px;left:6px;font-weight:900;color:white;text-shadow:0 2px 6px rgba(0,0,0,0.12);font-size:12px;background:rgba(0,0,0,0.18);padding:4px 8px;border-radius:8px;}
    .playfield{position:absolute;inset:10px 10px 10px 10px;pointer-events:auto}
    /* children: è¦–è¦ºä¸Šç¸®å° 40%ï¼ˆå³ 60% å°ºå¯¸ï¼‰ï¼Œä½†ç¢°æ’æ¡†ä»¥ç¸®å°å¾Œçš„å°ºå¯¸åˆ¤å®š */
    .child{
      position:absolute;
      width:84px;
      height:100px;
      border-radius:12px;
      background:linear-gradient(180deg,#fff,#fffcec);
      box-shadow:0 8px 16px rgba(20,20,60,0.08);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;padding:8px;cursor:pointer;user-select:none;z-index:30;overflow:hidden;
      transform-origin:center center;
      /* æˆ‘å€‘æŠŠè¦–è¦ºç¸®æ”¾ 0.6ï¼Œä¾†é”æˆã€Œç¸®å°40%ã€çš„æ•ˆæœ */
      transform: scale(0.6);
    }
    .child img{width:72px;height:72px;object-fit:cover;border-radius:10px}
    .child .face{width:48px;height:48px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:20px;box-shadow:inset 0 -6px 10px rgba(0,0,0,0.08)}
    .child .label{font-size:12px;color:#333}
    .gift{position:absolute;width:56px;height:56px;border-radius:10px;background:linear-gradient(180deg,var(--gold),#ffdb6b);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 26px rgba(0,0,0,0.18);transform-origin:center;z-index:35}
    .gift img{width:100%;height:100%;object-fit:contain;border-radius:8px}
    .sidebar{width:300px;display:flex;flex-direction:column;gap:12px}
    .card{background:var(--panel);border-radius:12px;padding:14px;box-shadow:var(--shadow)}
    .meter{height:12px;background:linear-gradient(90deg,#fff 0%, #fff 100%);border-radius:12px;overflow:hidden;border:2px solid rgba(0,0,0,0.04)}
    .meter > i{display:block;height:100%;background:linear-gradient(90deg,#ffd54a,#ff9b4f);width:0%;transition:width 300ms ease}
    .btn{display:inline-flex;gap:8px;align-items:center;justify-content:center;padding:10px 12px;border-radius:10px;cursor:pointer;border:none;font-weight:800;font-size:14px}
    .btn-primary{background:linear-gradient(180deg,var(--accent),#0ea5ff);color:white;box-shadow:0 8px 18px rgba(59,180,255,0.18)}
    .btn-ghost{background:transparent;border:2px dashed rgba(0,0,0,0.06);color:var(--text)}
    .overlay{position:absolute;inset:0;background:rgba(6,10,20,0.35);display:flex;align-items:center;justify-content:center;z-index:80;backdrop-filter:blur(2px)}
    .modal{background:white;border-radius:12px;padding:22px;box-shadow:0 18px 40px rgba(0,0,0,0.36);max-width:420px;text-align:center}
    .final-score{font-size:40px;font-weight:900;color:var(--gold);margin:12px 0}
    .tips{font-size:12px;color:rgba(0,0,0,0.6)}
    .proximityHint{
      position:absolute;
      z-index:50;
      background:rgba(255,255,255,0.95);
      border-radius:10px;
      padding:6px 10px;
      box-shadow:0 6px 18px rgba(0,0,0,0.12);
      font-size:13px;
      display:none;
    }
    /* next gift display */
    .next-gift{
      display:flex;align-items:center;gap:10px;padding:10px;border-radius:12px;background:linear-gradient(180deg,#fff,#fffaf0);box-shadow:var(--shadow);
    }
    .next-gift .label{font-weight:800}
    .next-gift .preview{width:72px;height:72px;border-radius:10px;overflow:hidden;background:linear-gradient(180deg,#fff,#fff);display:flex;align-items:center;justify-content:center;border:1px solid rgba(0,0,0,0.04)}
    .next-gift .preview img{width:100%;height:100%;object-fit:contain}
    @media (max-width:960px){.wrap{padding:10px;flex-direction:column}.sidebar{width:100%}}
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="å¯æ“æ§è–èª•è€äººæ´¾ç¦®éŠæˆ²">
    <div class="game-area" id="gameArea">
      <div class="hud">
        <div class="title-badge">
          <div class="logo" aria-hidden="true">ğŸ…</div>
          <div>
            <div class="title">Santa Claus is coming to town</div>
            <div class="subtitle">æ´¾ç¦®ç‰©çµ¦å°æœ‹å‹å§=ï¼</div>
          </div>
        </div>

        <div class="controls" aria-hidden="false">
          <div class="panel">
            <div style="text-align:right;">
              <div class="small">æ™‚é–“</div>
              <div class="big" id="timerDisplay">60</div>
            </div>
          </div>
          <div class="panel">
            <div style="text-align:right;">
              <div class="small">åˆ†æ•¸</div>
              <div class="big" id="scoreDisplay">0</div>
            </div>
          </div>
        </div>
      </div>

      <div class="stage" id="stage" aria-live="polite">
        <div class="playfield" id="playfield" tabindex="0" aria-label="éŠæˆ²å€åŸŸ">
          <!-- Santa (controllable) -->
          <div class="santa" id="santa" role="application" aria-label="è–èª•è€äºº">
            <!-- image will be inserted by JS if available, otherwise fallback label -->
            <div class="label">è–èª•è€äºº</div>
          </div>

          <!-- proximity hint -->
          <div id="proximityHint" class="proximityHint">é è¿‘å°æœ‹å‹æ‰å¯æ´¾ç¦®ç‰©</div>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between;">
        <div class="tips">æ“ä½œï¼šæ–¹å‘éµ / WASD ç§»å‹•ï¼›æ»‘é¼ æ‹–å‹•è–èª•è€äººï¼›é è¿‘å°æœ‹å‹å¾ŒæŒ‰ç©ºç™½éµæˆ–é»æ“Šå°æœ‹å‹æ´¾ç¦®ç‰©ã€‚</div>
        <div>
          <button class="btn btn-primary" id="startBtn">é–‹å§‹éŠæˆ²</button>
          <button class="btn btn-ghost" id="resetBtn">é‡æ–°é–‹å§‹</button>
        </div>
      </div>

      <!-- final overlay (hidden initially) -->
      <div id="finalOverlay" class="overlay" style="display:none" role="dialog" aria-modal="true">
        <div class="modal" id="finalModal">
          <div style="font-weight:900;font-size:20px">å›åˆçµæŸ</div>
          <div class="final-score" id="finalScore">0</div>
          <div id="finalMsg">å†æ¥å†å²ï¼</div>
          <div style="margin-top:14px;">
            <button class="btn btn-primary" id="playAgain">å†ç©ä¸€æ¬¡</button>
            <button class="btn btn-ghost" id="closeOverlay">é—œé–‰</button>
          </div>
        </div>
      </div>

    </div>

    <div class="sidebar">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div style="font-size:13px;color:rgba(0,0,0,0.6)">ç›®æ¨™åˆ†æ•¸</div>
            <div style="font-size:22px;font-weight:900;color:var(--green)" id="targetDisplay">1000</div>
          </div>
          <div style="text-align:right;">
            <div style="font-size:13px;color:rgba(0,0,0,0.6)">æœ€é«˜åˆ†</div>
            <div style="font-size:22px;font-weight:900;color:#6b21a8" id="bestDisplay">0</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="meter" aria-hidden="true">
            <i id="progressBar" style="width:0%"></i>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:800;margin-bottom:8px;">éŠæˆ²èªªæ˜</div>
        <ol style="padding-left:18px;margin:0;">
          <li>æ¯å›åˆ 60 ç§’ï¼Œç”¨éµç›¤æˆ–æ»‘é¼ æ§åˆ¶è–èª•è€äººç§»å‹•ï¼ŒæŒ‰ç©ºç™½éµæˆ–é»æ“Šå°æœ‹å‹å˜—è©¦æ´¾ç¦®ç‰©ã€‚</li>
          <li>æ”¶åˆ°ç¦®ç‰©çš„å°æœ‹å‹æœƒé–‹å¿ƒé›¢é–‹ï¼Œæ¯æ¬¡ +10 åˆ†ã€‚</li>
        </ol>
      </div>

      <div class="card" id="feedbackCard" aria-live="polite">
        <div style="font-weight:800;margin-bottom:8px;">å³æ™‚åé¥‹</div>
        <div id="feedbackText">æº–å‚™å¥½äº†å—ï¼ŸæŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ï¼</div>
      </div>

      <!-- Next gift display in the right-bottom area -->
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div class="next-gift" aria-live="polite">
            <div>
              <div class="label">ä¸‹ä¸€ä»½ç¦®ç‰©</div>
              <div style="font-size:12px;color:rgba(0,0,0,0.55)">é è¿‘å°æœ‹å‹ä¸¦æ´¾é€æ™‚æœƒä½¿ç”¨</div>
            </div>
            <div class="preview" id="nextGiftPreview" aria-hidden="false" title="ä¸‹ä¸€ä»½ç¦®ç‰©">
              <!-- image inserted by JS or fallback -->
              <div id="nextGiftFallback" style="font-size:28px">ğŸ</div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Minimal audio placeholders (è«‹ä¸Šç·šæ™‚æ›¿æ›æˆå¯¦éš›éŸ³æ•ˆ) -->
  <audio id="sfxGift" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>
  <audio id="sfxHappy" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>
  <audio id="sfxFinal" preload="auto"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQAAAAA="></audio>

  <script>
    // Elements
    const playfield = document.getElementById('playfield');
    const santa = document.getElementById('santa');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const feedbackText = document.getElementById('feedbackText');
    const progressBar = document.getElementById('progressBar');
    const targetDisplay = document.getElementById('targetDisplay');
    const bestDisplay = document.getElementById('bestDisplay');
    const finalOverlay = document.getElementById('finalOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const finalMsg = document.getElementById('finalMsg');
    const playAgainBtn = document.getElementById('playAgain');
    const closeOverlay = document.getElementById('closeOverlay');
    const proximityHint = document.getElementById('proximityHint');
    const nextGiftPreview = document.getElementById('nextGiftPreview');
    const nextGiftFallback = document.getElementById('nextGiftFallback');

    const sfxGift = document.getElementById('sfxGift');
    const sfxHappy = document.getElementById('sfxHappy');
    const sfxFinal = document.getElementById('sfxFinal');

    // Game state
    let timeLeft = 60;
    let timer = null;
    let score = 0;
    let running = false;
    let target = 1000;
    let best = 0;

    // Santa movement state
    let vel = {x:0,y:0};
    const speed = 220; // px/sec
    let keys = {left:false,right:false,up:false,down:false};
    let lastFrame = null;
    let dragging = false;
    let dragOffset = {x:0,y:0};

    // proximity threshold (distance in px to be considered "beside")
    const PROXIMITY_DIST = 200; // å·²æ›´æ–°ç‚º 200px

    // assets filenames (assumed in same folder as HTML)
    const santaImageFile = 'Santa.png';
    const kidImages = ['Boy1.png','Boy2.png','Girl1.png','Girl2.png'];
    const giftImages = ['Gift1.png','Gift2.png','Gift3.png','Gift4.png','Gift5.png'];

    // currently selected next gift (index into giftImages)
    let nextGiftIndex = 0;

    // visual scale applied to children (0.6 means 60% size, ç¸®å° 40%)
    const CHILD_VISUAL_SCALE = 0.6;

    // collision scale used for children (we use same as visual here, but it's separated soå¯ä»¥å¾®èª¿)
    const CHILD_COLLISION_SCALE = 0.6;

    // utility random
    function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    // try to insert santa image if available
    function tryLoadSantaImage(){
      const img = new Image();
      img.onload = ()=> {
        // insert image inside santa container
        santa.innerHTML = '';
        img.alt = 'Santa';
        santa.appendChild(img);
        const label = document.createElement('div'); label.className='label'; label.textContent='è–èª•è€å…¬å…¬';
        santa.appendChild(label);
      };
      img.onerror = ()=> {
        // keep existing fallback (label)
      };
      img.src = santaImageFile;
    }

    // Place santa in starting position
    function resetSantaPosition(){
      const pfW = playfield.clientWidth, pfH = playfield.clientHeight;
      santa.style.left = Math.max(20, pfW/6) + 'px';
      santa.style.top = Math.max(20, pfH - 160) + 'px';
    }

    // Helper: compute collision box center and radius for an element
    // We'll represent collision area as a circle (center x,y relative to playfield, radius)
    function getCollisionCircleForElement(el, options = {}){
      // options.scale: scale to apply to element's bounding box for collision (e.g. 0.6)
      const rect = el.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const scale = options.scale ?? 1.0;
      const cx = rect.left - pfRect.left + rect.width/2;
      const cy = rect.top - pfRect.top + rect.height/2;
      // use average of width/height and apply scale, divide by 2 to approximate radius
      const radius = ( (rect.width + rect.height) / 4 ) * scale;
      return { x: cx, y: cy, r: radius };
    }

    // Spawn N children randomly, static (no movement), and avoid overlap with santa and other children
    function spawnChildren(count = 8){
      // remove existing children
      Array.from(playfield.querySelectorAll('.child')).forEach(n=>n.remove());
      const w = playfield.clientWidth;
      const h = playfield.clientHeight;
      const padding = 20;
      const positions = [];
      const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });

      for(let i=0;i<count;i++){
        // generate non-overlapping-ish positions (consider child's collision radius at collision scale)
        let x,y,attempt=0;
        let childWidth = 84, childHeight = 100;
        const childRadius = ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE;
        do{
          x = padding + Math.random()*(w - padding*2 - childWidth);
          y = padding + Math.random()*(h - padding*2 - childHeight);
          attempt++;
          // compute center for candidate
          const cx = x + childWidth/2;
          const cy = y + childHeight/2;
          // check against existing positions
          let ok = true;
          for(const p of positions){
            const dx = p.cx - cx;
            const dy = p.cy - cy;
            const minDist = (p.r + childRadius) + 10; // small margin
            if(Math.hypot(dx,dy) < minDist){ ok = false; break; }
          }
          // check against santa collision circle so they don't spawn overlapping santa
          const dxs = santaCircle.x - cx;
          const dys = santaCircle.y - cy;
          if(Math.hypot(dxs,dys) < (santaCircle.r + childRadius + 20)) ok = false;

          if(ok) break;
        }while(attempt < 80);
        positions.push({ x, y, cx: x + childWidth/2, cy: y + childHeight/2, r: ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE });
      }

      positions.forEach(pos=>{
        const el = document.createElement('div');
        el.className = 'child';
        el.setAttribute('role','button');
        el.setAttribute('tabindex','0');

        // try to pick an image from kidImages
        const img = new Image();
        const pick = kidImages[rand(0,kidImages.length-1)];
        img.src = pick;
        img.alt = 'å°æœ‹å‹';
        img.onload = ()=>{
          // if image loaded, use it
          while(el.firstChild) el.removeChild(el.firstChild);
          img.style.width = '72px';
          img.style.height = '72px';
          el.appendChild(img);
          const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
          el.appendChild(label);
        };
        img.onerror = ()=>{
          // fallback to face emoji + label
          while(el.firstChild) el.removeChild(el.firstChild);
          const face = document.createElement('div'); face.className='face'; face.textContent = ['ğŸ™‚','ğŸ˜Š','ğŸ˜„','ğŸ˜‹'][rand(0,3)];
          const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
          el.appendChild(face); el.appendChild(label);
        };

        // place (note: because .child has transform: scale(0.6), the visual position will be scaled visually.
        // to keep intuitive placements we set the left/top as if unscaled)
        el.style.left = pos.x + 'px';
        el.style.top = pos.y + 'px';
        // set data-scale as reference
        el.dataset.collisionScale = String(CHILD_COLLISION_SCALE);
        el.style.transform = `scale(${CHILD_VISUAL_SCALE})`; // visual shrink

        // click to attempt gifting
        el.addEventListener('click', (ev)=>{
          if(!running) return;
          attemptGiftTo(el);
        });

        playfield.appendChild(el);
      });
    }

    // Attempt to give gift to child: must be within proximity (using collision circles + PROXIMITY_DIST)
    function attemptGiftTo(kidEl){
      if(!kidEl || !running) return;
      // compute distance between centers (playfield coordinates)
      const sRect = santa.getBoundingClientRect();
      const kRect = kidEl.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const sx = sRect.left - pfRect.left + sRect.width/2;
      const sy = sRect.top - pfRect.top + sRect.height/2;
      const kx = kRect.left - pfRect.left + kRect.width/2;
      const ky = kRect.top - pfRect.top + kRect.height/2;
      const centerDist = Math.hypot(sx - kx, sy - ky);

      // compute effective collision radii
      const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });
      const kidCircle = getCollisionCircleForElement(kidEl, { scale: CHILD_COLLISION_SCALE });

      // effective distance threshold = centerDist - santaRadius - kidRadius
      const edgeDistance = Math.max(0, centerDist - santaCircle.r - kidCircle.r);

      // check: consider allowed proximity threshold (PROXIMITY_DIST)
      if(edgeDistance <= PROXIMITY_DIST){
        deliverGift(kidEl);
      } else {
        showProximityHint('å†é è¿‘ä¸€é»æ‰èƒ½æ´¾ç¦®ç‰©å–”ï¼');
      }
    }

    // Deliver gift: show happy reaction, remove child and spawn a new one later
    function deliverGift(kidEl){
      // safety: ignore if already leaving
      if(kidEl.dataset.leaving === '1') return;
      kidEl.dataset.leaving = '1';
      // play gift sound
      try{ sfxGift.currentTime = 0; sfxGift.play(); }catch(e){}
      // show gift image flying to kid (visual)
      const kidRect = kidEl.getBoundingClientRect();
      const santaRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();

      // create a flying gift element based on current nextGiftIndex
      const flying = document.createElement('div');
      flying.className = 'gift';
      flying.style.left = (santaRect.left - pfRect.left + santaRect.width/2 - 28) + 'px';
      flying.style.top = (santaRect.top - pfRect.top + santaRect.height/2 - 28) + 'px';
      // try to use image
      const giftImg = new Image();
      giftImg.src = giftImages[nextGiftIndex];
      giftImg.alt = 'gift';
      giftImg.onload = ()=> { flying.appendChild(giftImg); };
      giftImg.onerror = ()=> { flying.textContent = 'ğŸ'; flying.style.fontSize='28px'; flying.style.display='flex'; flying.style.alignItems='center'; flying.style.justifyContent='center'; };
      playfield.appendChild(flying);

      // animate flying to kid center (taking into account kid visual scale)
      const toX = kidRect.left - pfRect.left + kidRect.width/2 - 28;
      const toY = kidRect.top - pfRect.top + kidRect.height/2 - 28;
      flying.animate([
        { transform: 'translate(0,0) scale(1)', opacity:1 },
        { transform: `translate(${toX - (santaRect.left - pfRect.left + santaRect.width/2 - 28)}px, ${toY - (santaRect.top - pfRect.top + santaRect.height/2 - 28)}px) scale(0.8)`, opacity:1 },
        { transform: `translate(${toX - (santaRect.left - pfRect.left + santaRect.width/2 - 28)}px, ${toY - (santaRect.top - pfRect.top + santaRect.height/2 - 28)}px) scale(0.4)`, opacity:0.0 }
      ], { duration: 700, easing: 'ease-in' });

      setTimeout(()=>{ try{ flying.remove(); }catch(e){} }, 800);

      // child happy pop (emoji or small heart)
      const heart = document.createElement('div');
      heart.style.position='absolute';
      heart.style.left = (kidRect.left - pfRect.left + kidRect.width/2 - 18) + 'px';
      heart.style.top = (kidRect.top - pfRect.top - 10) + 'px';
      heart.style.fontSize='28px';
      heart.style.pointerEvents='none';
      heart.style.zIndex='45';
      heart.textContent = 'ğŸ’–';
      playfield.appendChild(heart);
      heart.animate([{transform:'translateY(0px) scale(0.8)', opacity:0},{transform:'translateY(-18px) scale(1.1)', opacity:1},{transform:'translateY(-40px) scale(1.0)', opacity:0}],{duration:900,easing:'ease-out'});
      setTimeout(()=>heart.remove(),900);

      // child fade out
      kidEl.animate([{opacity:1},{opacity:0}],{duration:700,easing:'ease-in'});

      // play happy sound
      try{ sfxHappy.currentTime = 0; sfxHappy.play(); }catch(e){}

      // add score +10 and feedback
      score += 10;
      updateScoreUI();
      feedbackText.textContent = 'æ´¾æˆåŠŸï¼å°æœ‹å‹å¥½é–‹å¿ƒï¼ +10 åˆ†';

      // after fade, remove child and spawn a new one after short delay
      setTimeout(()=>{
        try{ kidEl.remove(); }catch(e){}
        // spawn a new kid at random position after short delay
        setTimeout(()=>spawnNewChild(), 600);
      }, 720);

      // after delivering, pick a new next gift
      pickNextGift();
    }

    function spawnNewChild(){
      // spawn single child in random position (avoid too close to santa)
      const w = playfield.clientWidth;
      const h = playfield.clientHeight;
      const padding = 20;
      let x,y,attempt=0;
      let childWidth = 84, childHeight = 100;
      const childRadius = ((childWidth + childHeight) / 4) * CHILD_COLLISION_SCALE;
      const santaCircle = getCollisionCircleForElement(santa, { scale: 1.0 });

      do{
        x = padding + Math.random()*(w - padding*2 - childWidth);
        y = padding + Math.random()*(h - padding*2 - childHeight);
        attempt++;
        const cx = x + childWidth/2;
        const cy = y + childHeight/2;
        if(Math.hypot(cx - santaCircle.x, cy - santaCircle.y) < (santaCircle.r + childRadius + 30)) continue;
        // also ensure not overlapping other children
        let overlap = false;
        Array.from(playfield.querySelectorAll('.child')).forEach(c=>{
          const rect = c.getBoundingClientRect();
          const otherCx = rect.left - playfield.getBoundingClientRect().left + rect.width/2;
          const otherCy = rect.top - playfield.getBoundingClientRect().top + rect.height/2;
          const otherR = ((rect.width + rect.height)/4) * CHILD_COLLISION_SCALE;
          if(Math.hypot(cx - otherCx, cy - otherCy) < (otherR + childRadius + 10)) overlap = true;
        });
        if(overlap) continue;
        break;
      }while(attempt < 80);
      const el = document.createElement('div');
      el.className = 'child';
      el.setAttribute('role','button');
      el.setAttribute('tabindex','0');

      // try to load image
      const img = new Image();
      const pick = kidImages[rand(0,kidImages.length-1)];
      img.src = pick;
      img.alt = 'å°æœ‹å‹';
      img.onload = ()=>{
        while(el.firstChild) el.removeChild(el.firstChild);
        img.style.width = '72px';
        img.style.height = '72px';
        el.appendChild(img);
        const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
        el.appendChild(label);
      };
      img.onerror = ()=>{
        while(el.firstChild) el.removeChild(el.firstChild);
        const face = document.createElement('div'); face.className='face'; face.textContent = ['ğŸ™‚','ğŸ˜Š','ğŸ˜„','ğŸ˜‹'][rand(0,3)];
        const label = document.createElement('div'); label.className='label'; label.textContent='å°æœ‹å‹';
        el.appendChild(face); el.appendChild(label);
      };

      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.dataset.collisionScale = String(CHILD_COLLISION_SCALE);
      el.style.transform = `scale(${CHILD_VISUAL_SCALE})`;

      el.addEventListener('click', (ev)=>{
        if(!running) return;
        attemptGiftTo(el);
      });

      playfield.appendChild(el);
    }

    // compute center distance between two elements
    function distanceBetweenElementsCenter(a,b){
      const af = a.getBoundingClientRect();
      const bf = b.getBoundingClientRect();
      const pf = playfield.getBoundingClientRect();
      const ax = af.left - pf.left + af.width/2;
      const ay = af.top - pf.top + af.height/2;
      const bx = bf.left - pf.left + bf.width/2;
      const by = bf.top - pf.top + bf.height/2;
      return Math.hypot(ax - bx, ay - by);
    }

    // show temporary hint near santa
    let hintTimer = null;
    function showProximityHint(text){
      proximityHint.textContent = text;
      // position above santa
      const sRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const left = sRect.left - pfRect.left + sRect.width/2 - 80;
      const top = sRect.top - pfRect.top - 46;
      proximityHint.style.left = Math.max(6, Math.min(playfield.clientWidth - 160, left)) + 'px';
      proximityHint.style.top = Math.max(6, top) + 'px';
      proximityHint.style.display = 'block';
      proximityHint.style.opacity = '1';
      if(hintTimer) clearTimeout(hintTimer);
      hintTimer = setTimeout(()=>{ proximityHint.style.display = 'none'; }, 1200);
    }

    // Update score UI
    function updateScoreUI(){
      scoreDisplay.textContent = score;
      const pct = Math.min(100, Math.round((score/target)*100));
      progressBar.style.width = pct + '%';
      if(score > best){ best = score; bestDisplay.textContent = best; }
    }

    // pick next gift randomly and update preview UI
    function pickNextGift(){
      nextGiftIndex = rand(0, giftImages.length - 1);
      // attempt to load image
      nextGiftPreview.innerHTML = '';
      nextGiftFallback.style.display = 'none';
      const img = new Image();
      img.onload = ()=>{
        img.alt = 'ä¸‹ä¸€ä»½ç¦®ç‰©';
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'contain';
        nextGiftPreview.appendChild(img);
      };
      img.onerror = ()=>{
        nextGiftFallback.style.display = 'block';
        nextGiftFallback.textContent = 'ğŸ';
      };
      img.src = giftImages[nextGiftIndex];
    }

    // Timer and game flow
    function startGame(){
      if(running) return;
      // reset
      score = 0; updateScoreUI();
      timeLeft = 60; timerDisplay.textContent = timeLeft;
      running = true;
      spawnChildren(8);
      resetSantaPosition();
      pickNextGift();
      feedbackText.textContent = 'å›åˆé–‹å§‹ï¼é è¿‘å°æœ‹å‹ä¸¦æ´¾ç¦®ç‰©å§ï¼';
      lastFrame = performance.now();
      requestAnimationFrame(frameLoop);
      timer = setInterval(()=>{
        timeLeft--;
        timerDisplay.textContent = timeLeft;
        if(timeLeft <= 0) endGame();
      },1000);
    }

    function endGame(){
      if(!running) return;
      running = false;
      clearInterval(timer);
      feedbackText.textContent = `æ™‚é–“åˆ°ï¼æœ¬å›åˆåˆ†æ•¸ï¼š${score} åˆ†`;
      finalScoreEl.textContent = score;
      finalMsg.textContent = score >= target ? 'å¤ªæ£’äº†ï¼é”æˆç›®æ¨™ï¼' : 'åŠ æ²¹ï¼Œä¸‹æ¬¡ä¸€å®šå¯ä»¥æ›´é«˜åˆ†ï¼';
      try{ sfxFinal.currentTime = 0; sfxFinal.play(); }catch(e){}
      finalOverlay.style.display = 'flex';
    }

    function resetGame(){
      clearInterval(timer);
      running = false;
      timeLeft = 60; timerDisplay.textContent = timeLeft;
      score = 0; updateScoreUI();
      spawnChildren(8);
      resetSantaPosition();
      pickNextGift();
      feedbackText.textContent = 'å·²é‡æ–°é–‹å§‹ï¼ŒæŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ï¼';
      finalOverlay.style.display = 'none';
    }

    // Frame loop: movement (no child drifting)
    function frameLoop(now){
      if(!lastFrame) lastFrame = now;
      const dtMs = now - lastFrame;
      const dt = dtMs / 1000;
      lastFrame = now;

      // keyboard velocity
      let mvX = 0, mvY = 0;
      if(keys.left) mvX -= 1;
      if(keys.right) mvX += 1;
      if(keys.up) mvY -= 1;
      if(keys.down) mvY += 1;
      const mag = Math.hypot(mvX,mvY);
      if(mag > 0){
        mvX = mvX / mag;
        mvY = mvY / mag;
      }
      // apply movement
      if(running || Object.values(keys).some(v=>v)){
        const curLeft = parseFloat(getComputedStyle(santa).left);
        const curTop = parseFloat(getComputedStyle(santa).top);
        const nx = curLeft + mvX * speed * dt;
        const ny = curTop + mvY * speed * dt;
        // clamp inside playfield
        const pfW = playfield.clientWidth;
        const pfH = playfield.clientHeight;
        const sW = santa.clientWidth;
        const sH = santa.clientHeight;
        santa.style.left = Math.max(0, Math.min(pfW - sW, nx)) + 'px';
        santa.style.top = Math.max(0, Math.min(pfH - sH, ny)) + 'px';
      }

      if(running) requestAnimationFrame(frameLoop);
    }

    // Keyboard handling
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
      if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
      if(e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false; // intentional fallback
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
      if(e.code === 'Space'){
        e.preventDefault();
        if(!running) return;
        const nearest = chooseNearestChildForSanta();
        if(nearest) attemptGiftTo(nearest);
      }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
      if(e.code === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
      if(e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
      if(e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
    });

    // Choose nearest child to santa (for space key)
    function chooseNearestChildForSanta(){
      const kids = Array.from(playfield.querySelectorAll('.child'));
      if(kids.length === 0) return null;
      const sRect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      const sx = sRect.left - pfRect.left + sRect.width/2;
      const sy = sRect.top - pfRect.top + sRect.height/2;
      let minD = Infinity; let pick = null;
      kids.forEach(k=>{
        const r = k.getBoundingClientRect();
        const x = r.left - pfRect.left + r.width/2;
        const y = r.top - pfRect.top + r.height/2;
        const d = Math.hypot(x-sx,y-sy);
        if(d < minD){ minD = d; pick = k; }
      });
      return pick;
    }

    // Mouse drag handling for santa
    santa.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      dragging = true;
      santa.setPointerCapture(e.pointerId);
      const rect = santa.getBoundingClientRect();
      const pfRect = playfield.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
    });
    santa.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const pfRect = playfield.getBoundingClientRect();
      let x = e.clientX - pfRect.left - dragOffset.x;
      let y = e.clientY - pfRect.top - dragOffset.y;
      // clamp
      x = Math.max(0, Math.min(playfield.clientWidth - santa.clientWidth, x));
      y = Math.max(0, Math.min(playfield.clientHeight - santa.clientHeight, y));
      santa.style.left = x + 'px';
      santa.style.top = y + 'px';
    });
    santa.addEventListener('pointerup', (e)=>{
      dragging = false;
      try{ santa.releasePointerCapture(e.pointerId); }catch(e){}
    });
    santa.addEventListener('pointercancel', ()=>{ dragging=false; });

    // Start / reset / overlay handlers
    startBtn.addEventListener('click', ()=>startGame());
    resetBtn.addEventListener('click', ()=>resetGame());
    playAgainBtn.addEventListener('click', ()=>{ finalOverlay.style.display = 'none'; resetGame(); startGame(); });
    closeOverlay.addEventListener('click', ()=>{ finalOverlay.style.display = 'none'; });

    // save best score
    try{
      const saved = localStorage.getItem('santa_proximity_best');
      if(saved){ best = parseInt(saved); bestDisplay.textContent = best; }
    }catch(e){}
    setInterval(()=>{ try{ localStorage.setItem('santa_proximity_best', String(best)); }catch(e){} }, 2000);

    // initial spawn & position
    window.addEventListener('load', ()=>{
      tryLoadSantaImage();
      spawnChildren(8);
      resetSantaPosition();
      pickNextGift();
    });

    // click background to focus for keyboard
    playfield.addEventListener('click', ()=>playfield.focus());

    // keep santa inside on resize
    window.addEventListener('resize', ()=>{
      const pfW = playfield.clientWidth, pfH = playfield.clientHeight;
      const curLeft = parseFloat(getComputedStyle(santa).left);
      const curTop = parseFloat(getComputedStyle(santa).top);
      santa.style.left = Math.max(0, Math.min(pfW - santa.clientWidth, curLeft)) + 'px';
      santa.style.top = Math.max(0, Math.min(pfH - santa.clientHeight, curTop)) + 'px';
    });

    // unlock audio on user gesture
    document.addEventListener('click', function unlockAudio(){
      try{
        sfxGift.volume = 0.9; sfxHappy.volume = 0.9; sfxFinal.volume = 0.9;
        sfxGift.play().then(()=>sfxGift.pause()).catch(()=>{});
        sfxHappy.play().then(()=>sfxHappy.pause()).catch(()=>{});
        sfxFinal.play().then(()=>sfxFinal.pause()).catch(()=>{});
      }catch(e){}
      document.removeEventListener('click', unlockAudio);
    });

  </script>
</body>
</html>
